\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{courier}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{bytefield}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{color}
\usepackage{alltt}
\usepackage{tabu, booktabs}
\usepackage{longtable}

\newcommand{\rmst}{{\it\small rmst}}

\title{Rekordbox Export Structure Analysis}
\author{James Elliott\\Deep Symmetry, LLC}

\begin{document}

\maketitle

\abstract{The files written to external media by rekordbox for use in
  player hardware contain a wealth of information that can be used in
  place of queries to the remotedb server on the players, which is
  important because they can be obtained from the players' NFS
  servers, even if there are four players in use sharing the same
  media. Under those circumstances, remotedb queries are impossible.
  This article documents what has been learned so far about the
  files, and how to interpret them.}

\pagestyle{headings}

%% Define macros used to draw more complex message byte fields with
%% labeled headers and color-related sections.

\newcommand\hexhead{
  \bitbox[]{1}{\tiny\bfseries 0}
  \bitbox[]{1}{\tiny\bfseries 1}
  \bitbox[]{1}{\tiny\bfseries 2}
  \bitbox[]{1}{\tiny\bfseries 3}
  \bitbox[]{1}{\tiny\bfseries 4}
  \bitbox[]{1}{\tiny\bfseries 5}
  \bitbox[]{1}{\tiny\bfseries 6}
  \bitbox[]{1}{\tiny\bfseries 7}
  \bitbox[]{1}{\tiny\bfseries 8}
  \bitbox[]{1}{\tiny\bfseries 9}
  \bitbox[]{1}{\tiny\bfseries a}
  \bitbox[]{1}{\tiny\bfseries b}
  \bitbox[]{1}{\tiny\bfseries c}
  \bitbox[]{1}{\tiny\bfseries d}
  \bitbox[]{1}{\tiny\bfseries e}
  \bitbox[]{1}{\tiny\bfseries f}
}

\newcommand{\baselinealign}[1]{%
  \centering
  \strut#1%
}

\newcommand{\colorbitbox}[4][rlbt]{%
  \sbox0{\bitbox[#1]{#3}{#4}}%
 \makebox[0pt][l]{\textcolor{#2}{\rule[-\dp0]{\wd0}{\ht0}}}%
 \bitbox[#1]{#3}{#4}%
}

\definecolor{lightgreen}{rgb}{0.64,1,0.71}
\definecolor{yellow}{rgb}{1,1,0.71}
\definecolor{lightred}{rgb}{1,0.7,0.71}
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightpurple}{rgb}{1,0.71,1}

\tableofcontents

\newpage

\section{Database Exports}

The starting point for finding track metadata from a player is the
database export file, which can be found within rekordbox media at the
path {\tt PIONEER/rekordbox/export.pdb} (if you are using the Crate
Digger {\tt FileFetcher} to request this file, use that path as the
{\tt filePath} argument, and use a {\tt mountPath} value of {\tt /B/}
if you want to read it from the SD slot, or {\tt /C/} to obtain it
from the USB slot).

The file is a relational database format designed to be efficiently
used by very low power devices (there were deployments on 16 bit
devices with 32K of RAM). Today you are most likely to encounter it
within the Pioneer Professional DJ ecosystem, because it is the format
that their rekordbox software uses to write USB and SD media which can
be mounted in DJ controllers and used to play and mix music.

The file consists of a series of fixed size pages. The first page
contains a file header which defines the page size and the locations
of database tables of different types, by the index of their first
page. The rest of the pages consist of the data pages for all of the
tables identified in the header.

Each table is made up of a series of rows which may be spread across
any number of pages. The pages start with a header describing the page
and linking to the next page. The rest of the page is used as a heap:
rows are scattered around it, and located using an index structure
that builds backwards from the end of the page. Each row of a given
type has a fixed size structure which links to any variable-sized
strings by their offsets within the page.

As changes are made to the table, some records may become unused, and
there may be gaps within the heap that are too small to be used by
other data. There is a bit map in the row index that identifies which
rows are actually present. Rows that are not present must be ignored:
they do not contain valid (or even necessarily well-formed) data.

The majority of the work in reverse-engineering this format was
performed by Henry
Betts\footnote{\url{https://github.com/henrybetts/Rekordbox-Decoding}}
and Fabian
Lesniak\footnote{\url{https://github.com/flesniak/python-prodj-link}},
to whom I am hugely grateful.

\subsection{File Header}
\label{sec:fileHeader}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{4}{$len\_page$} &
      \bitbox{4}{$num\_tables$} & \bitbox{4}{$next_u$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown$} & \bitbox{4}{$sequence$} & \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} &
      & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \wordbox[lr]{1}{Table Pointers} \\
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{File Header}
  \label{fig:fileHeader}
\end{figure}

Unless otherwise stated, all multi-byte numbers in the file are stored
in little-endian byte order. Field names used in the Figures match the
IDs assigned to them in the Kaitai Struct
specification\footnote{\url{https://github.com/Deep-Symmetry/crate-digger/blob/master/src/main/kaitai/rekordbox_pdb.ksy}},
unless that is too long to fit, in which case a subscripted
abbreviation is used, and the text will mention the actual ID.

The first page begins with the file header, shown in
Figure~\ref{fig:fileHeader}. The header starts with four zero bytes,
followed by a four-byte integer, $len\_page$ at byte~{\tt 04}, that
establishes the size of each page (including this first one), in
bytes. This is followed by another four-byte integer, $num\_tables$ at
byte~{\tt 08}, which reports the number of different tables that are
present in the file. Each table will have a table pointer entry in the
``Table pointers'' section of the file header, described below, that
identifies and locates the table.

The four-byte integer $next_u$ at byte~{\tt 0c} has an unknown
purpose, but Mr. Lesniak named it {\tt next\_unused\_page} and said
``Not used as any {\tt empty\_candidate}, points past the end of the
file.'' The four-byte integer $sequence$, at byte~{\tt 14}, was
described ``Always incremented by at least one, sometimes by two or
three.'' and I assume this means it reflects a version number that
rekordbox updates when synchronizing to the exported media.

Finally, there is another series of four zero bytes, and then the
header ends with the list of table pointers which begins at byte~{\tt
  1c}. There are as many of these as specified by $num\_tables$, and
each has the structure shown in Figure~\ref{fig:tablePointer}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$type$} & \bitbox{4}{$empty_c$} & \bitbox{4}{$first\_page$} & \bitbox{4}{$last\_page$}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{Table Pointer}
  \label{fig:tablePointer}
\end{figure}

Each Table Pointer is a series of four four-byte integers. The first,
$type$, identifies the type of table being defined. The known table
types are shown in Table~\ref{table:tableTypes}. The second value, at
byte~{\tt 04} of the Table Pointer, was called {\tt empty\_candidate}
by Mr. Lesniak. It may link to a chain of empty pages if the database
is ever garbage collected, but this is speculation on my part.

\begin{longtabu}{rlX}
  \toprule
  {\bfseries Type} & {\bfseries Name} & {\bfseries Row Content} \endhead

  \bottomrule \\
  \caption{Table Types} \endfoot

  0 & tracks & Track metadata: title, artist, genre, artwork ID,
  playing time, etc. \label{table:tableTypes} \\

  1 & genres & Musical genres, for reference by tracks and searching.
  \\

  2 & artists & Artists, for reference by tracks and searching. \\

  3 & albums & Albums, for reference by tracks and searching. \\

  4 & labels & Music labels, for reference by tracks and searching. \\

  5 & keys & Musical keys, for reference by tracks, searching, and key
  matching. \\

  6 & colors & Color labels, for reference by tracks and searching. \\

  7 & playlist\_tree & Describes the hierarchical tree structure of
  available playlists and folders grouping them. \\

  8 & playlist\_entries & Links tracks to playlists, in the rightp
  order. \\

  13 & artwork & File paths of album artwork images. \\

  16 & columns & Details not yet confirmed. \\

  19 & history & Records the tracks played during performances. \\

\end{longtabu}

Other than the type, the two important values are $first\_page$ at
byte~{\tt 08} and $last\_page$ at byte~{\tt 0c}. These tell us how to
find the table. They are page indices, where the page containing the
file header has index 0, the page with index 1 begins at
byte~$len\_page$, and so on. In other words, the first page of the
table identified by the current Table Pointer can be found within the
file starting at the byte $len\_page \times first\_page$.

The table is a linked list of pages: each page contains the index of
the next page after it. However, you need to keep track of the
$last\_page$ value for the table, because it tells you not to try to
follow the next page link once you reach the page with that index. (If
you do keep going, you will start reading pages of some different
table.) The structure of the table pages themselves are described
in the next section.

As far as we know, the remainder of the first page after the table
pointers is unused.


\subsection{Table Pages}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{4}{$page\_index$} &
      \bitbox{4}{$type$} & \bitbox{4}{$next\_page$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown_1$} & \bitbox{4}{$unknown_2$} & \bitbox{1}{$n_{rs}$} & \bitbox{1}{$u_3$} &
      \bitbox{1}{$u_4$} & \bitbox{1}{$p_f$} & \bitbox{2}{$free_s$} & \bitbox{2}{$used_s$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{2}{$u_5$} & \bitbox{2}{$num_{rl}$} & \bitbox{2}{$u_6$} & \bitbox{2}{$u_7$} &
      \bitbox[lrt]{8}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \wordbox[lr]{1}{$heap$} \\
      \skippedwords \\
      \wordbox[lr]{1}{$row\_groups$} \\
      \bitbox[lb]{6}{} & \bitbox[]{2}{\ldots} &
      \bitbox{2}{$ofs_{17}$} & \bitbox{2}{$ofs_{16}$} & \bitbox{2}{$row_{pf_1}$} & \bitbox{2}{$ofs_{15}$} \\
      \bitbox{2}{$ofs_{14}$} & \bitbox{2}{$ofs_{13}$} & \bitbox{2}{$ofs_{12}$} & \bitbox{2}{$ofs_{11}$} &
      \bitbox{2}{$ofs_{10}$} & \bitbox{2}{$ofs_{9}$} & \bitbox{2}{$ofs_{8}$} & \bitbox{2}{$ofs_{7}$} \\
      \bitbox{2}{$ofs_{6}$} & \bitbox{2}{$ofs_{5}$} & \bitbox{2}{$ofs_{4}$} & \bitbox{2}{$ofs_{3}$} &
      \bitbox{2}{$ofs_{2}$} & \bitbox{2}{$ofs_{1}$} & \bitbox{2}{$ofs_{0}$} & \bitbox{2}{$row_{pf_0}$}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{Table Page}
  \label{fig:tablePage}
\end{figure}

The table header is followed by the table pages themselves. These each
have the size specified by $len\_page$ in Figure~\ref{fig:fileHeader},
and the structure shown in Figure~\ref{fig:tablePage}.

Data pages all seem to have the header structure described here, but
not all of them actually store data. Some of them are ``strange'' and
we have not yet figured out why. The discussion below describes how to
recognize a strange page, and avoid trying to read it as a data page.

The first four bytes of a table page always seem to be zero. This is
followed by a four-byte value $page\_index$ which identifies the index
of this page within the list of table pages (the header has index 0,
the first actual data page the index 1, and so on). This value seems
to be redundant, because it can be calculated by dividing the offset
of the start of the page by $len\_page$, but perhaps it serves as a
sanity check.

This is followed by another four-byte value, $type$, which identifies
the type of the page, using the values shown in
Table~\ref{table:tableTypes}. This again seems redundant because the
table header which was followed to reach this page also identified the
table type, but perhaps it is another sanity check, or an alternate
way to tell, when following page links, that you have reached the end
of the table you are interested in. Speaking of which, the next
four-byte value, $next\_page$, is that link: it identifies the index
at which the next page of this table can be found, as long as we have
not already reached the final page of the table, as described in
Section~\ref{sec:fileHeader}.

The exact meaning of $unknown_1$ is unclear. Mr. Flesinak said
``sequence number (0$\rightarrow$1: 8$\rightarrow$13, 1$\rightarrow$2:
22, 2$\rightarrow$3: 27)'' but I don't know how to interpret that.
Even less is known about $unknown_2$. But $num\_rows\_small$ at
byte~{\tt 18} within the page (abbrviated $n_{rs}$ in
Figure~\ref{fig:tablePage}) holds the number of rows that are present
in the page, unless $num\_rows\_large$ (below) holds a value that is
larger (but not equal to {\tt 1fff}). This seems like a strange
mechanism for dealing with the fact that some tables (like playlist
entries) have a lot of very small rows, too many to count with a
single byte. But then why not just always use $num\_rows\_large$?

The purpose of the next two bytes are is also unclear. Of $u_3$ Mr.
Flesniak said ``a bitmask (first track: 32)'', and he described $u_4$
as often 0, sometimes larger, especially for pages with a high number
of rows (e.g. 12 for 101 rows).

Byte~{\tt 1b} is called $page\_flags$ (abbrviated $p_f$ in
Figure~\ref{fig:tablePage}). According to Mr. Flesniak, ``strange''
(non-data) pages will have the value {\tt 44} or {\tt 64}, and other
pages have had the values {\tt 24} or {\tt 34}. Crate Digger considers
a page to be a data page if $page\_flags \& {\tt 40} = 0$.

Bytes~{\tt 1c-1d} are called $free\_size$ (abbrviated $free_s$ in
Figure~\ref{fig:tablePage}), and store the amount of unused space in
the page heap (excluding the row index which is built backwards from
the end of the page); $used\_size$ at bytes~{\tt 1c-1d} (abbrviated
$used_s$) stores the number of bytes that are in use in the page heap.

Bytes~{\tt 20-21}, $u_5$, are of unclear purpose. Mr. Flesniak labeled
them ``(0$\rightarrow$1: 2).''

Bytes~{\tt 20-21}, $num\_rows\_large$ (abbrviated $num_{rl}$ in
Figure~\ref{fig:tablePage}) hold the number of entries in the row
index at the end of the page when that value is too large to fit into
$num\_rows\_small$ (as mentioned above), and that situation seems to
be indicated when this value is larger than $num\_rows\_small$, but
not equal to {\tt 1fff}.

$u_6$ at bytes~{\tt 24-25} seems to have the value {\tt 1004} for
strange pages, and {\tt 0000} for data pages. And Mr. Flesniak
describes $u_7$ at bytes~{\tt 26-27} as ``always 0 except 1 for
history pages, num entries for strange pages?''

After these header fields comes the page heap. Rows are allocated
within this heap starting at byte~{\tt 28}. Since rows can be
different sizes, there needs to be a way to locate them. This takes
the form of a row index, which is built from the end of the page
backwards, in groups of up to sixteen row pointers along with a
bitmask saying which of those rows are still part of the table (they
might have been deleted).

The number of row index entries is determined by the value of either
$num\_rows\_small$ or $num\_rows\_large$ as described above.

The bit mask for the first group of up to sixteen rows, labeled
$row_{pf_0}$ in Figure~\ref{fig:tablePage} (meaning ``row presence
flags group 0''), is found in the last two bytes of the page. The low
order bit of this value will be set if row 0 is really present, the
next bit if row 1 is really present, and so on. The two bytes before
these flags, labeled $ofs_0$, store the offset of the first row in the
page. This offset is the number of bytes past the end of the page
header at which the row itself can be found. So if row 0 begins at the
very beginning of the heap, at byte~{\tt 28} in the page, $ofs_0$
would have the value {\tt 0000}.

As more rows are added to the page, space is allocated for them in the
heap, and additional index entries are added at the end of the heap,
growing backwards. Once there have been sixteen rows added, all of the
bits in $row_{pf_0}$ are accounted for, and when another row is added,
before its offset entry $ofs_{16}$ can be added, another row bit-mask
entry $row_{pf_1}$ needs to be allocated. And so the row index grows
backwards towards the rows that are being added forwards, and once
they are too close for a new row to fit, the page is full, and another
page gets allocated to the table.

\subsection{Table Rows}

The structure of the rows themselves is determined by the $type$ of
the table, using the values shown in Table~\ref{table:tableTypes}.

\subsubsection{Album Rows}

Album rows hold an album name and ID along with an artist association.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{2}{$u_1$} & \bitbox{2}{$index_s$} & \bitbox{4}{$unknown_2$} &
      \bitbox{4}{$artist\_id$} & \bitbox{4}{$id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown_3$} & \bitbox{1}{$u_4$} & \bitbox{1}{$o_n$} &
      \bitbox[lt]{10}{}
    \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Album Row}
  \label{fig:albumRow}
\end{figure}

To be continued...

\section{Crate Digger}

You can find a Java library that can parse the structures described in
this research, and that can retrieve them from players' NFS servers,
at: \url{https://github.com/deep-symmetry/crate-digger}

The project also contains Kaitai Struct specifications for the file
structures, which were used to automatically generate Java classes to
parse them, and which can be used to generate equivalent code for a
variety of other programming languages.

There are also ONC RPC specification files which were similarly used
to generate Java classes to communicate with the NFSv2 servers in the
players, and which can likely be used to generate structures for other
languages as well.

\begin{appendix}

  \addcontentsline{toc}{section}{\listfigurename}
  \listoffigures

  \addcontentsline{toc}{section}{\listtablename}
  \listoftables

  \begin{center}
    \begin{samepage}
      \includegraphics[width=4cm]{assets/DS-Logo-bw-4k}

      \vspace{0.25cm}
      \url{http://deepsymmetry.org}
    \end{samepage}
  \end{center}

\end{appendix}

\end{document}
