\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{courier}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{bytefield}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{color}
\usepackage{alltt}
\usepackage{tabu, booktabs}
\usepackage{longtable}

\newcommand{\rmst}{{\it\small rmst}}

\title{Rekordbox Export Structure Analysis}
\author{James Elliott\\Deep Symmetry, LLC}

\begin{document}

\maketitle

\abstract{The files written to external media by rekordbox for use in
  player hardware contain a wealth of information that can be used in
  place of queries to the remotedb server on the players, which is
  important because they can be obtained from the players' NFS
  servers, even if there are four players in use sharing the same
  media. Under those circumstances, remotedb queries are impossible.
  This article documents what has been learned so far about the
  files, and how to interpret them.}

\pagestyle{headings}

%% Define macros used to draw more complex message byte fields with
%% labeled headers and color-related sections.

\newcommand\hexhead{
  \bitbox[]{1}{\tiny\bfseries 0}
  \bitbox[]{1}{\tiny\bfseries 1}
  \bitbox[]{1}{\tiny\bfseries 2}
  \bitbox[]{1}{\tiny\bfseries 3}
  \bitbox[]{1}{\tiny\bfseries 4}
  \bitbox[]{1}{\tiny\bfseries 5}
  \bitbox[]{1}{\tiny\bfseries 6}
  \bitbox[]{1}{\tiny\bfseries 7}
  \bitbox[]{1}{\tiny\bfseries 8}
  \bitbox[]{1}{\tiny\bfseries 9}
  \bitbox[]{1}{\tiny\bfseries a}
  \bitbox[]{1}{\tiny\bfseries b}
  \bitbox[]{1}{\tiny\bfseries c}
  \bitbox[]{1}{\tiny\bfseries d}
  \bitbox[]{1}{\tiny\bfseries e}
  \bitbox[]{1}{\tiny\bfseries f}
}

\newcommand{\baselinealign}[1]{%
  \centering
  \strut#1%
}

\newcommand{\colorbitbox}[4][rlbt]{%
  \sbox0{\bitbox[#1]{#3}{#4}}%
 \makebox[0pt][l]{\textcolor{#2}{\rule[-\dp0]{\wd0}{\ht0}}}%
 \bitbox[#1]{#3}{#4}%
}

\definecolor{lightgreen}{rgb}{0.64,1,0.71}
\definecolor{yellow}{rgb}{1,1,0.71}
\definecolor{lightred}{rgb}{1,0.7,0.71}
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightpurple}{rgb}{1,0.71,1}

\tableofcontents

\newpage

\section{Database Exports}

The starting point for finding track metadata from a player is the
database export file, which can be found within rekordbox media at the
path {\tt PIONEER/rekordbox/export.pdb} (if you are using the Crate
Digger {\tt FileFetcher} to request this file, use that path as the
{\tt filePath} argument, and use a {\tt mountPath} value of {\tt /B/}
if you want to read it from the SD slot, or {\tt /C/} to obtain it
from the USB slot).

The file is a relational database format designed to be efficiently
used by very low power devices (there were deployments on 16 bit
devices with 32K of RAM). Today you are most likely to encounter it
within the Pioneer Professional DJ ecosystem, because it is the format
that their rekordbox software uses to write USB and SD media which can
be mounted in DJ controllers and used to play and mix music.

The file consists of a series of fixed size pages. The first page
contains a file header which defines the page size and the locations
of database tables of different types, by the index of their first
page. The rest of the pages consist of the data pages for all of the
tables identified in the header.

Each table is made up of a series of rows which may be spread across
any number of pages. The pages start with a header describing the page
and linking to the next page. The rest of the page is used as a heap:
rows are scattered around it, and located using an index structure
that builds backwards from the end of the page. Each row of a given
type has a fixed size structure which links to any variable-sized
strings by their offsets within the page.

As changes are made to the table, some records may become unused, and
there may be gaps within the heap that are too small to be used by
other data. There is a bit map in the row index that identifies which
rows are actually present. Rows that are not present must be ignored:
they do not contain valid (or even necessarily well-formed) data.

The majority of the work in reverse-engineering this format was
performed by Henry
Betts\footnote{\url{https://github.com/henrybetts/Rekordbox-Decoding}}
and Fabian
Lesniak\footnote{\url{https://github.com/flesniak/python-prodj-link}},
to whom I am hugely grateful.

\subsection{File Header}
\label{sec:fileHeader}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{4}{$len\_page$} &
      \bitbox{4}{$num\_tables$} & \bitbox{4}{$next_u$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown$} & \bitbox{4}{$sequence$} & \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} &
      & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \wordbox[lr]{1}{Table Pointers} \\
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{File Header}
  \label{fig:fileHeader}
\end{figure}

Unless otherwise stated, all multi-byte numbers in the file are stored
in little-endian byte order. Field names used in the Figures match the
IDs assigned to them in the Kaitai Struct
specification\footnote{\url{https://github.com/Deep-Symmetry/crate-digger/blob/master/src/main/kaitai/rekordbox_pdb.ksy}},
unless that is too long to fit, in which case a subscripted
abbreviation is used, and the text will mention the actual struct
field name.

The first page begins with the file header, shown in
Figure~\ref{fig:fileHeader}. The header starts with four zero bytes,
followed by a four-byte integer, $len\_page$ at byte~{\tt 04}, that
establishes the size of each page (including this first one), in
bytes. This is followed by another four-byte integer, $num\_tables$ at
byte~{\tt 08}, which reports the number of different tables that are
present in the file. Each table will have a table pointer entry in the
``Table pointers'' section of the file header, described below, that
identifies and locates the table.

The four-byte integer $next_u$ at byte~{\tt 0c} has an unknown
purpose, but Mr. Lesniak named it {\tt next\_unused\_page} and said
``Not used as any {\tt empty\_candidate}, points past the end of the
file.'' The four-byte integer $sequence$, at byte~{\tt 14}, was
described ``Always incremented by at least one, sometimes by two or
three.'' and I assume this means it reflects a version number that
rekordbox updates when synchronizing to the exported media.

Finally, there is another series of four zero bytes, and then the
header ends with the list of table pointers which begins at byte~{\tt
  1c}. There are as many of these as specified by $num\_tables$, and
each has the structure shown in Figure~\ref{fig:tablePointer}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$type$} & \bitbox{4}{$empty_c$} & \bitbox{4}{$first\_page$} & \bitbox{4}{$last\_page$}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{Table Pointer}
  \label{fig:tablePointer}
\end{figure}

Each Table Pointer is a series of four four-byte integers. The first,
$type$, identifies the type of table being defined. The known table
types are shown in Table~\ref{table:tableTypes}. The second value, at
byte~{\tt 04} of the Table Pointer, was called {\tt empty\_candidate}
by Mr. Lesniak. It may link to a chain of empty pages if the database
is ever garbage collected, but this is speculation on my part.

\begin{longtabu}{rlX}
  \toprule
  {\bfseries Type} & {\bfseries Name} & {\bfseries Row Content} \endhead

  \bottomrule \\
  \caption{Table Types} \endfoot

  0 & tracks & Track metadata: title, artist, genre, artwork ID,
  playing time, etc.,
  Section~\ref{sec:trackRows}. \label{table:tableTypes} \\

  1 & genres & Musical genres, for reference by tracks and searching,
  Section~\ref{sec:genreRows}. \\

  2 & artists & Artists, for reference by tracks and searching,
  Section~\ref{sec:artistRows}. \\

  3 & albums & Albums, for reference by tracks and searching,
  Section~\ref{sec:albumRows}. \\

  4 & labels & Music labels, for reference by tracks and searching,
  Section~\ref{sec:labelRows}. \\

  5 & keys & Musical keys, for reference by tracks, searching, and key
  matching, Section~\ref{sec:keyRows}. \\

  6 & colors & Color labels, for reference by tracks and searching,
  Section~\ref{sec:colorRows}. \\

  7 & playlist\_tree & Describes the hierarchical tree structure of
  available playlists and folders grouping them,
  Section~\ref{sec:playlistTreeRows}. \\

  8 & playlist\_entries & Links tracks to playlists, in the right
  order, Section~\ref{sec:playlistEntryRows}. \\

  13 & artwork & File paths of album artwork images,
  Section~\ref{sec:artworkRows}. \\

  16 & columns & Details not yet confirmed. \\

  19 & history & Records the tracks played during performances. \\

\end{longtabu}

Other than the type, the two important values are $first\_page$ at
byte~{\tt 08} and $last\_page$ at byte~{\tt 0c}. These tell us how to
find the table. They are page indices, where the page containing the
file header has index 0, the page with index 1 begins at
byte~$len\_page$, and so on. In other words, the first page of the
table identified by the current Table Pointer can be found within the
file starting at the byte $len\_page \times first\_page$.

The table is a linked list of pages: each page contains the index of
the next page after it. However, you need to keep track of the
$last\_page$ value for the table, because it tells you not to try to
follow the next page link once you reach the page with that index. (If
you do keep going, you will start reading pages of some different
table.) The structure of the table pages themselves are described
in the next section.

As far as we know, the remainder of the first page after the table
pointers is unused.


\subsection{Table Pages}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{4}{$page\_index$} &
      \bitbox{4}{$type$} & \bitbox{4}{$next\_page$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown_1$} & \bitbox{4}{$unknown_2$} & \bitbox{1}{$n_{rs}$} & \bitbox{1}{$u_3$} &
      \bitbox{1}{$u_4$} & \bitbox{1}{$p_f$} & \bitbox{2}{$free_s$} & \bitbox{2}{$used_s$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{2}{$u_5$} & \bitbox{2}{$num_{rl}$} & \bitbox{2}{$u_6$} & \bitbox{2}{$u_7$} &
      \bitbox[lrt]{8}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \wordbox[lr]{1}{$heap$} \\
      \skippedwords \\
      \wordbox[lr]{1}{$row\_groups$} \\
      \bitbox[lb]{6}{} & \bitbox[]{2}{\ldots} &
      \bitbox{2}{$ofs_{17}$} & \bitbox{2}{$ofs_{16}$} & \bitbox{2}{$row_{pf_1}$} & \bitbox{2}{$ofs_{15}$} \\
      \bitbox{2}{$ofs_{14}$} & \bitbox{2}{$ofs_{13}$} & \bitbox{2}{$ofs_{12}$} & \bitbox{2}{$ofs_{11}$} &
      \bitbox{2}{$ofs_{10}$} & \bitbox{2}{$ofs_{9}$} & \bitbox{2}{$ofs_{8}$} & \bitbox{2}{$ofs_{7}$} \\
      \bitbox{2}{$ofs_{6}$} & \bitbox{2}{$ofs_{5}$} & \bitbox{2}{$ofs_{4}$} & \bitbox{2}{$ofs_{3}$} &
      \bitbox{2}{$ofs_{2}$} & \bitbox{2}{$ofs_{1}$} & \bitbox{2}{$ofs_{0}$} & \bitbox{2}{$row_{pf_0}$}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{Table Page}
  \label{fig:tablePage}
\end{figure}

The table header is followed by the table pages themselves. These each
have the size specified by $len\_page$ in Figure~\ref{fig:fileHeader},
and the structure shown in Figure~\ref{fig:tablePage}.

Data pages all seem to have the header structure described here, but
not all of them actually store data. Some of them are ``strange'' and
we have not yet figured out why. The discussion below describes how to
recognize a strange page, and avoid trying to read it as a data page.

The first four bytes of a table page always seem to be zero. This is
followed by a four-byte value $page\_index$ which identifies the index
of this page within the list of table pages (the header has index 0,
the first actual data page the index 1, and so on). This value seems
to be redundant, because it can be calculated by dividing the offset
of the start of the page by $len\_page$, but perhaps it serves as a
sanity check.

This is followed by another four-byte value, $type$, which identifies
the type of the page, using the values shown in
Table~\ref{table:tableTypes}. This again seems redundant because the
table header which was followed to reach this page also identified the
table type, but perhaps it is another sanity check, or an alternate
way to tell, when following page links, that you have reached the end
of the table you are interested in. Speaking of which, the next
four-byte value, $next\_page$, is that link: it identifies the index
at which the next page of this table can be found, as long as we have
not already reached the final page of the table, as described in
Section~\ref{sec:fileHeader}.

The exact meaning of $unknown_1$ is unclear. Mr. Flesinak said
``sequence number (0$\rightarrow$1: 8$\rightarrow$13, 1$\rightarrow$2:
22, 2$\rightarrow$3: 27)'' but I don't know how to interpret that.
Even less is known about $unknown_2$. But $num\_rows\_small$ at
byte~{\tt 18} within the page (abbrviated $n_{rs}$ in
Figure~\ref{fig:tablePage}) holds the number of rows that are present
in the page, unless $num\_rows\_large$ (below) holds a value that is
larger (but not equal to {\tt 1fff}). This seems like a strange
mechanism for dealing with the fact that some tables (like playlist
entries) have a lot of very small rows, too many to count with a
single byte. But then why not just always use $num\_rows\_large$?

The purpose of the next two bytes are is also unclear. Of $u_3$ Mr.
Flesniak said ``a bitmask (first track: 32)'', and he described $u_4$
as often 0, sometimes larger, especially for pages with a high number
of rows (e.g. 12 for 101 rows).

Byte~{\tt 1b} is called $page\_flags$ (abbrviated $p_f$ in
Figure~\ref{fig:tablePage}). According to Mr. Flesniak, ``strange''
(non-data) pages will have the value {\tt 44} or {\tt 64}, and other
pages have had the values {\tt 24} or {\tt 34}. Crate Digger considers
a page to be a data page if $page\_flags \& {\tt 40} = 0$.

Bytes~{\tt 1c-1d} are called $free\_size$ (abbrviated $free_s$ in
Figure~\ref{fig:tablePage}), and store the amount of unused space in
the page heap (excluding the row index which is built backwards from
the end of the page); $used\_size$ at bytes~{\tt 1c-1d} (abbrviated
$used_s$) stores the number of bytes that are in use in the page heap.

Bytes~{\tt 20-21}, $u_5$, are of unclear purpose. Mr. Flesniak labeled
them ``(0$\rightarrow$1: 2).''

Bytes~{\tt 20-21}, $num\_rows\_large$ (abbrviated $num_{rl}$ in
Figure~\ref{fig:tablePage}) hold the number of entries in the row
index at the end of the page when that value is too large to fit into
$num\_rows\_small$ (as mentioned above), and that situation seems to
be indicated when this value is larger than $num\_rows\_small$, but
not equal to {\tt 1fff}.

$u_6$ at bytes~{\tt 24-25} seems to have the value {\tt 1004} for
strange pages, and {\tt 0000} for data pages. And Mr. Flesniak
describes $u_7$ at bytes~{\tt 26-27} as ``always 0 except 1 for
history pages, num entries for strange pages?''

After these header fields comes the page heap. Rows are allocated
within this heap starting at byte~{\tt 28}. Since rows can be
different sizes, there needs to be a way to locate them. This takes
the form of a row index, which is built from the end of the page
backwards, in groups of up to sixteen row pointers along with a
bitmask saying which of those rows are still part of the table (they
might have been deleted).

The number of row index entries is determined by the value of either
$num\_rows\_small$ or $num\_rows\_large$ as described above.

The bit mask for the first group of up to sixteen rows, labeled
$row_{pf_0}$ in Figure~\ref{fig:tablePage} (meaning ``row presence
flags group 0''), is found in the last two bytes of the page. The low
order bit of this value will be set if row 0 is really present, the
next bit if row 1 is really present, and so on. The two bytes before
these flags, labeled $ofs_0$, store the offset of the first row in the
page. This offset is the number of bytes past the end of the page
header at which the row itself can be found. So if row 0 begins at the
very beginning of the heap, at byte~{\tt 28} in the page, $ofs_0$
would have the value {\tt 0000}.

As more rows are added to the page, space is allocated for them in the
heap, and additional index entries are added at the end of the heap,
growing backwards. Once there have been sixteen rows added, all of the
bits in $row_{pf_0}$ are accounted for, and when another row is added,
before its offset entry $ofs_{16}$ can be added, another row bit-mask
entry $row_{pf_1}$ needs to be allocated. And so the row index grows
backwards towards the rows that are being added forwards, and once
they are too close for a new row to fit, the page is full, and another
page gets allocated to the table.

\subsection{Table Rows}

The structure of the rows themselves is determined by the $type$ of
the table, using the values shown in Table~\ref{table:tableTypes}.

\subsubsection{Album Rows}
\label{sec:albumRows}

Album rows hold an album name and ID along with an artist association,
with the structure shown in Figure~\ref{fig:albumRow}. The unknown
value at bytes~{\tt 00-01} seems to usually have the values {\tt 80
  00}. It is followed by a two-byte value Mr. Flesniak called
$index\_shift$, although I don't know what that means, and another
four bytes of unknown purpose. But at bytes~{\tt 08-0b} we finally
find a value we have a use for: $artist\_id$ holds the ID of an artist
row associated with this track row. This is followed by $id$, the ID
of this track row itself, at bytes~{\tt 0c-0f}. We assume that there
are index tables somewhere that would let us locate the page and row
index of a record given its table type and ID, but we have not yet
found and figured them out.

This is followed by five more bytes with unknown meaning, and the
final byte in the row, $ofs\_name$ is a pointer to the track name
(labeled $o_n$ in Figure~\ref{fig:albumRow}. To find the location of
the name, add $ofs\_name$ bytes to the address of the start of the
track row itself. The name itself is encoded in a surprisingly baroque
way, explained in Section~\ref{sec:deviceSqlStrings}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{2}{$u_1$} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$unknown_2$} &
      \bitbox{4}{$artist\_id$} & \bitbox{4}{$id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown_3$} & \bitbox{1}{$u_4$} & \bitbox{1}{$o_n$} &
      \bitbox[lt]{10}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Album Row}
  \label{fig:albumRow}
\end{figure}

\subsubsection{Artist Rows}
\label{sec:artistRows}

Artist rows hold an Artist name and ID, with the structure shown in
Figure~\ref{fig:artistRowNear} or Figure~\ref{fig:artistRowFar}. The
$subtype$ value at bytes~{\tt 00-01} determines which variant is used.
If the artist name was allocated close enough to the row to be reached
by a single byte offset, offset, $subtype$ has the value {\tt 0060},
and the row has the structure in Figure~\ref{fig:artistRowNear}. If
the name is too far away for that, $subtype$ has the value {\tt 0064}
and the row has the structure in Figure~\ref{fig:artistRowFar}.

In either case, $subtype$ is followed by the unexplained two-byte
value found in many row types that Mr. Flesniak called $index\_shift$,
and then by $id$, the ID of this artist row itself, at bytes~{\tt
  04-07}, an unknown value, and $ofs\_name\_near$ (labeled $o_n$ in
Figure~\ref{fig:artistRowNear}), the one-byte name offset used only in
the first variant.

If $subtype$ is {\tt 0064}, the value of $ofs\_name\_near$ is ignored,
and instead the two-byte value $ofs\_name\_far$ (labeled $o_{far}$ in
Figure~\ref{fig:artistRowFar}) is used.

Whichever name offset is used, it is a pointer to the artist name. To
find the location of the name, add the value of the offset to the
address of the start of the artist row itself. This gives the address
of a DeviceSQL string holding the name, with the structure explained
in Section~\ref{sec:deviceSqlStrings}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{2}{\tt 0060} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$id$} &
    \bitbox{1}{$u_1$} & \bitbox{1}{$o_n$} & \bitbox[]{6}{}
  \end{bytefield}
  \caption{Artist Row with Nearby Name}
  \label{fig:artistRowNear}
\end{figure}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{2}{\tt 0064} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$id$} &
    \bitbox{1}{$u_1$} & \bitbox{1}{$o_n$} & \bitbox{2}{$o_{far}$} & \bitbox[]{4}{}
  \end{bytefield}
  \caption{Artist Row with Far Name}
  \label{fig:artistRowFar}
\end{figure}

\subsubsection{Artwork Rows}
\label{sec:artworkRows}

Artwork rows hold an $id$ (which tracks refer to) and the path at
which the corresponding album art image file can be found, with the
structure shown in Figure~\ref{fig:artworkRow}. Note that in this
case, the DeviceSQL string $path$ is embedded directly into the row
itself, rather than being located elsewhere in the heap through an
offset. The structure of the string itself is still as described in
Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$id$} & \bitbox[lrt]{12}{$path$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Artwork Row}
  \label{fig:artworkRow}
\end{figure}

\subsubsection{Color Rows}
\label{sec:colorRows}

Color rows hold a numeric color $id$ (which controls the actual color
displayed on the player interface) at bytes~{\tt 05-06} and a text
label or $name$ starting at byte~{\tt 08} which is a DeviceSQL string
shown in the information panel for tracks that are assigned the color.
The rows have the structure shown in Figure~\ref{fig:colorRow}. There
are several bytes in the row that are not yet known to have any
meaning. The structure of $name$ is described in
Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$unknown_1$} & \bitbox{1}{$u_2$} & \bitbox{2}{$id$} & \bitbox{1}{$u_3$} & \bitbox[lrt]{8}{$name$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Color Row}
  \label{fig:colorRow}
\end{figure}

\subsubsection{Genre Rows}
\label{sec:genreRows}

Genre rows hold a numeric genre $id$ (which tracks can be assigned) at
bytes~{\tt 00-03} and a text $name$ starting at byte~{\tt 04} which is
a DeviceSQL string. The rows have the structure shown in
Figure~\ref{fig:genreRow}. The structure of $name$ is described in
Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$id$} & \bitbox[lrt]{12}{$name$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Genre or Label Row}
  \label{fig:genreRow}
\end{figure}

\subsubsection{Key Rows}
\label{sec:keyRows}

Key rows represent musical keys. They hold a numeric $id$ (which
tracks can be assigned) at bytes~{\tt 00-03} and a text $name$
starting at byte~{\tt 08} which is a DeviceSQL string. (There seems to
be a second copy of the ID at bytes~{\tt 04-07}.) The rows have the
structure shown in Figure~\ref{fig:keyRow}. The structure of $name$ is
described in Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$id$} & \bitbox{4}{$id2$} & \bitbox[lrt]{8}{$name$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Key Row}
  \label{fig:keyRow}
\end{figure}

\subsubsection{Label Rows}
\label{sec:labelRows}

Label rows represent record labels. They hold a numeric $id$ (which
tracks can be assigned) at bytes~{\tt 00-03} and a text $name$
starting at byte~{\tt 04} which is a DeviceSQL string. The rows have
the structure shown in Figure~\ref{fig:genreRow}. The structure of
$name$ is described in Section~\ref{sec:deviceSqlStrings}.

\subsubsection{Playlist Tree Rows}
\label{sec:playlistTreeRows}

Playlist tree rows are used to organize the hierarchical structure of
the playlist menu. There is probably an index somewhere that makes it
possible to find the right rows directly when loading a playlist, but
we have not yet figured out how indices work in DeviceSQL databases,
so Crate Digger simply reads all the rows and builds its own in-memory
index of the tree.

Playlist tree rows can either represent a playlist ``folder'' which
contains other folders and playlists, or a regular playlist which
holds only tracks. The rows are identified by an $id$ at bytes~{\tt
  0c-0f}, and also contain a $parent\_id$ at bytes~{\tt 00-03} which
is how the hierarchical structure is represented: the contents of a
folder are the other rows in this table whose $parent\_id$ folder is
equal to the $id$ of the folder.

Similarly, the tracks that make up a regular playlist are the Playlist
Entry Rows (described in Section~\ref{sec:playlistEntryRows}) whose
$playlist\_id$ is equal to this row's $id$.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$parent\_id$} & \bitbox{4}{} & \bitbox{4}{$sort\_order$} & \bitbox{4}{$id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$raw\_is\_folder$} & \bitbox[lrt]{12}{name}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Playlist Tree Row}
  \label{fig:playlistTreeRow}
\end{figure}

Each playlist tree row also has a text $name$ starting at byte~{\tt
  14} which is a DeviceSQL string displayed when navigating the
hierarchy, a $sort\_order$ indicator at bytes~{\tt 08-0b} (this may be
the same value used to select sort orders when requesting menus using
the {\tt dbserver} protocol, shown in Table~7 of the dysentery
Protocol Analysis paper, but this has not yet been confirmed), and a
value that specifies whether the row defines a folder or a playlist.
In the Kaitai Struct, this value is called $raw\_is\_folder$, is found
at bytes~{\tt 10-13}, and has a non-zero value for folders. For
convenience, the struct also defines a derived value, $is\_folder$,
which is a boolean.

The rows have the structure shown in Figure~\ref{fig:playlistTreeRow}.
The structure of $name$ is described in
Section~\ref{sec:deviceSqlStrings}.

\subsubsection{Playlist Entry Rows}
\label{sec:playlistEntryRows}

Playlist entry rows list the tracks that belong to a particular
playlist, and also establish the order in which they should be played.
They have a very simple structure, shown in
Figure~\ref{fig:playlistEntryRow}, containing only three values. The
$entry\_index$ at bytes~{\tt 00-03} specifies the position within the
playlist at which this entry belongs. The $track\_id$ at bytes~{\tt
  04-07} identifies the track to be played at this position in the
playlist, by corresponding to the $id$ of a row in the Track table
described in Section~\ref{sec:trackRows}, and the $playlist\_id$ at
bytes~{\tt 08-0b} identifies the playlist to which it belongs, by
corresponding to the $id$ of a row in the Playlist Tree described in
Section~\ref{sec:playlistTreeRows}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{4}{$entry\_index$} & \bitbox{4}{$track\_id$} & \bitbox{4}{$playlist\_id$} & \bitbox[]{4}{}
  \end{bytefield}
  \caption{Playlist Entry Row}
  \label{fig:playlistEntryRow}
\end{figure}

\subsubsection{Track Rows}
\label{sec:trackRows}

Track rows describe audio tracks that can be played from the media
export, and provide many details about the music inluding links to
other tables like artists, albums, keys, and others. They have the
structure shown in Figure~\ref{fig:trackRow}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{2}{$u_1$} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$bitmask$} & \bitbox{4}{$sample\_rate$} &
      \bitbox{4}{$composer\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$file\_size$} & \bitbox{4}{$u_2$} & \bitbox{2}{$u_3$} & \bitbox{2}{$u_4$} &
      \bitbox{4}{$artwork\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{4}{$key\_id$} & \bitbox{4}{$orig\_artist\_id$} & \bitbox{4}{$label\_id$} & \bitbox{4}{$remixer\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 30}
      \bitbox{4}{$bitrate$} & \bitbox{4}{$track\_number$} & \bitbox{4}{$tempo$} & \bitbox{4}{$genre\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 40}
      \bitbox{4}{$album\_id$} & \bitbox{4}{$artist\_id$} & \bitbox{4}{$id$} & \bitbox{2}{$disc_n$} &
      \bitbox{2}{$play_c$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 50}
      \bitbox{2}{$year$} & \bitbox{2}{$s_{depth}$} & \bitbox{2}{$dur$} & \bitbox{2}{$u_5$} &
      \bitbox{1}{$c_{id}$} & \bitbox{1}{$r$} & \bitbox{2}{$u_6$} & \bitbox{2}{$u_7$} & \bitbox{2}{$ofs_0$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 60}
      \bitbox{2}{$ofs_1$} & \bitbox{2}{$ofs_2$} & \bitbox{2}{$ofs_3$} & \bitbox{2}{$ofs_4$} &
      \bitbox{2}{$ofs_5$} & \bitbox{2}{$ofs_6$} & \bitbox{2}{$ofs_7$} & \bitbox{2}{$ofs_8$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 70}
      \bitbox{2}{$ofs_9$} & \bitbox{2}{$ofs_{10}$} & \bitbox{2}{$ofs_{11}$} & \bitbox{2}{$ofs_{12}$} &
      \bitbox{2}{$ofs_{13}$} & \bitbox{2}{$ofs_{14}$} & \bitbox{2}{$ofs_{15}$} & \bitbox{2}{$ofs_{16}$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 70}
      \bitbox{2}{$ofs_{17}$} & \bitbox{2}{$ofs_{18}$} & \bitbox{2}{$ofs_{19}$} & \bitbox{2}{$ofs_{20}$} & \bitbox[]{8}{}
    \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Track Row}
  \label{fig:trackRow}
\end{figure}

The first two bytes, labeled $u_1$, have an unknown purpose; they
usually are {\tt 24} followed by {\tt 00}. They are followed by the
unexplained two-byte value found in many row types that Mr. Flesniak
called $index\_shift$, and a four-byte value he called $bitmask$,
although we do not know what the bits mean. The value $sample\_rate$
at bytes~{\tt 08-0b} is the first one we have a solid understanding
of: it holds the playback sample rate of the audio file, in samples
per second.

Bytes~{\tt 0c-0f} hold the value $composer\_id$ which identifies the
composer of the track, if known, as a non-zero $id$ value of an Artist
row, as discussed in Section~\ref{sec:artistRows}. The size of the
audio file, in bytes, is found in $file\_size$ at bytes~{\tt 10-13}.
This is followed by an unknown four-byte value, $u_2$, which may be
another ID, and two unknown two-byte values, $u_3$ (about which Mr.
Flesniak says ``always 19048?'') and $u_4$ (``always 30967?'').

If there is cover art for the track, there will be a non-zero value in
$artwork\_id$ (bytes~{\tt 1c-1f}), identifying the $id$ of an Artwork
row, as discussed in section~\ref{sec:artworkRows}.

If a dominant musical key was identified for the track there will be a
non-zero value in $key\_id$ (bytes~{\tt 20-23}), which represents the
$id$ of a Key row, as discussed in Section~\ref{sec:keyRows}. If the
track is known to be a remake, the non-zero Artist row $id$
(Section~\ref{sec:artistRows}) of the original performer will be found
in $original\_artist\_id$ at bytes~{\tt 24-27}. If there is a known
record label for the track, the non-zero value in $label\_id$ will
link to the $id$ of a Label row $id$ as described in
Section~\ref{sec:labelRows}. Similarly, if there is a known remixer,
there will be a non-zero value in $remixer\_id$ (bytes~{\tt 2c-2f})
linking to the $id$ of an Artist row (Section~\ref{sec:artistRows}).

The field $bitrate$ at bytes~{\tt 30-33} stores the playback bit rate
of the track, and $track\_number$ at bytes~{\tt 34-37} holds the
position of the track within its album. $tempo$ at bytes~{\tt 38-3b}
holds the playback tempo of the start of the track in beats per
minute, multiplied by 100 (in order to support a precision of
$\frac{1}{100}$ BPM). If there is a known genre for the track, there
will be a non-zero value in $genre\_id$ at bytes~{\tt 3c-3f},
representing the $id$ of a Genre row as discussed in
Section~\ref{sec:genreRows}.

If the track is part of an album, there will be a non-zero value in
$album\_id$ at bytes~{\tt 40-43}, and this will be the $id$ of an
Album row as discussed in Section~\ref{sec:albumRows}. The Artist row
$id$ (Section~\ref{sec:artistRows}) of the primary performer
associated with the track is found in $artist\_id$ at bytes~{\tt
  44-47}. And the $id$ of the track itself is found in $id$ at
bytes~{\tt 48-4b}. If the album is known to consist of multiple discs,
the disc number on which this track is found will be in $disc\_number$
at bytes~{\tt 4c-4d}. And the number of times the track has been
played is found in $play\_count$ (bytes~{\tt 4e-4f}).

The year in which the track was recorded, if known, is in $year$ at
bytes~{\tt 50-51}. The sample depth of the track audio file (bits per
sample) is in $sample\_depth$ at bytes~{\tt 52-53}. The playback time
of the track (in seconds, at normal speed) is in $duration$ at
bytes~{\tt 54-55}. The purpose of the next two bytes, labeled $u_5$,
is unknown, they seem to always hold the value 41.

Byte~{\tt 58}, $color\_id$ (labeled $c_{id}$ in
Figure~\ref{fig:trackRow}), holds the color assigned to the track in
rekordbox, as the $id$ of a Color row (described in
Section~\ref{sec:colorRows}), or zero if no color has been assigned.
Byte~{\tt 59}, $rating$ (labeled $r$ in Figure~\ref{fig:trackRow})
holds the rating (0 to 5 stars) assigned the track. The next two
bytes, labeled $u_6$, have an unknown purpose, and seem to always have
the value 1. The two bytes after them, labeled $u_7$, are also
unknown; Mr. Flesniak said ``alternating 2 and 3''.

The rest of the track row is an array of 21 two-byte offsets that
point to DeviceSQL strings. To find the start of the string, add the
address of the start of the track row to the offset. The purpose of
each string is described in Table~\ref{table:trackStrings}, and the
structure of the strings themselves is explained in
Section~\ref{sec:deviceSqlStrings}.

For convenience, the strings can be accessed as Kaitai Struct instance
values with the names shown in the table.

\begin{longtabu}{rlX}

  \toprule
  {\bfseries Index} & {\bfseries Name} & {\bfseries Content} \endhead

  \bottomrule \\
  \caption{Track Offset Strings} \endfoot

  0 & $unknown\_string\_1$ \label{table:trackStrings} & Unknown, so far always empty. \\

  1 & $texter$ & Unknown, named by {\tt @flesniak}. \\

  2 & $unknown\_string\_2$ & Unknown, ``thought track number, wrong''. \\

  3 & $unknown\_string\_3$ & Unknown, ``Strange
  strings.''\footnote{Often zero length, sometimes low binary values,
    ASCII {\tt 01} or {\tt 02} as content.}. \\

  4 & $unknown\_string\_4$ & ``Strange strings'' (as above). \\

  5 & $messsage$ & Unknown, named by {\tt @flesniak}. \\

  6 & $kuvo\_public$ & Empty or {\tt "ON"}.\footnote{Apparently
    used rather than a simple bit flag to control whether the track
    information is visible on Kuvo.} \\

  7 & $autoload\_hotcues$ & Empty or {\tt
    "ON"}.\footnote{Apparently used rather than a simple bit flag to
    control whether hot cues are automatically loaded for the track.}
  \\

  8 & $unknown\_string\_5$ & Unknown. \\

  9 & $unknown\_string\_6$ & Unknown, usually empty. \\

  10 & $date\_added$ & When track was added to collection. \\

  11 & $release\_date$ & When track was released. \\

  12 & $mix\_name$ & Name of the track remix. \\

  13 & $unknown\_string\_7$ & Unknown, usually empty. \\

  14 & $analyze\_path$ & File path of track analysis, see
  Section~\ref{sec:analysisFiles}. \\

  15 & $analyze\_date$ & When track analysis was performed. \\

  16 & $comment$ & Track comment assigned by DJ. \\

  17 & $title$ & Track title. \\

  18 & $unknown\_string\_8$ & Unknown, usually empty. \\

  19 & $filename$ & Name of track audio file. \\

  20 & $file\_path$ & File path of track audio. \\

\end{longtabu}

\subsection{DeviceSQL Strings}
\label{sec:deviceSqlStrings}

Many row types store string values, sometimes by directly embedding
them, but more often by storing an offset to a location elsewhere in
the heap. In either case the string itself uses the strange structure
described in this section. Strings can be stored in a variety of
formats. The first byte of the structure, labeled $length\_and\_kind$
in the parsed Kaitai Struct, identifies the encoding type and, when
the value is odd, also the length (for short ASCII strings), as
detailed in Section~\ref{sec:shortAscii}.

\subsubsection{Long ASCII Strings}

If $length\_and\_kind$ has the value {\tt 40}, it is followed by a
two-byte $length$ field, and then followed by that many bytes of
ASCII-encoded string data, as shown in Figure~\ref{fig:longAscii}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{1}{\tt 40} & \bitbox{2}{$length$} & \bitbox[lrt]{13}{ASCII data}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Long ASCII DeviceSQL String}
  \label{fig:longAscii}
\end{figure}

\subsubsection{Long UTF-16 Big-Endian Strings}

If $length\_and\_kind$ has the value {\tt 90}, it is followed by a
two-byte $length$ field, and then followed by that many bytes of
UTF-16 big-endian encoded string data, as shown in Figure~\ref{fig:longUTF16BE}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{1}{\tt 90} & \bitbox{2}{$length$} &
      \bitbox[lrt]{13}{UTF-16 Big-Endian data}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Long UTF-16-BE DeviceSQL String}
  \label{fig:longUTF16BE}
\end{figure}

\subsubsection{Short ASCII Strings}
\label{sec:shortAscii}

If $length\_and\_kind$ has an odd value it is a $mangled\_length$,
labeled $m_l$ in Figure~\ref{fig:shortAscii}. This means we are
dealing with a short ASCII DeviceSQL string. To find the length of the
string data (which immediately follows this byte), subtract 1 from
$mangled\_length$, divide it by 2, and subtract 1 again.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{1}{$m_l$} & \bitbox[lrt]{15}{ASCII data}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Short ASCII DeviceSQL String}
  \label{fig:shortAscii}
\end{figure}

\section{Analysis Files}
\label{sec:analysisFiles}

When rekordbox analyzes tracks there is some data that is too big to
fit in the database itself. We have already seen some of that (the
album art images, and of course the track audio is left in the
filesystem as well). The other analysis data is organized into
``anlz'' files, whose path can be found in the DeviceSQL string
pointed to by index 14 in the string offsets found at the end of the
corresponding track row (see Table~\ref{table:trackStrings} in
Section~\ref{sec:trackRows}). These files have names like {\tt
  ANLZ0001.DAT} and their structure is described in this section.

The files are ``tagged type'' files, where there is an overall file
header section, and then each entry in the file has its own header
which identifies the type and length of that section.

Later player hardware added support for things like colored and
higher-resolution waveforms. Apparently these were deemed too large to
fit in the {\tt .DAT} files, so another file was introduced, which
shares the same base filename as the {\tt .DAT} file, but uses an
extension of {\tt .EXT} instead. Both kinds of file share the same
structure, but different sets of tags can be found in each.

\subsection{Analysis File Header}

For some reason the analysis files store their numbers in big-endian
byte order, the opposite of the {\tt export.pdb} database file. Field
names used in the Figures match the IDs assigned to them in the Kaitai
Struct
specification\footnote{\url{https://github.com/Deep-Symmetry/crate-digger/blob/master/src/main/kaitai/rekordbox_anlz.ksy}},
unless that is too long to fit, in which case a subscripted
abbreviation is used, and the text will mention the actual struct
field name.

The file itself starts with the four-character code {\tt PMAI} that
identifies its format. This file format identifier is followed a
four-byte value at bytes~{\tt 04-07}, $len\_header$, that specifies
the length of the file header in bytes. This is followed by another
four-byte value, $len\_file$, at bytes~{\tt 08-0b} that specifies the
length of the whole file in bytes.

The header seems to usually be {\tt 1c} bytes long, though we do not
yet know the purpose of any of the header values that come after
$len\_file$. After the header, the file consists of a series of tagged
sections, each with their own four-character code identifying the
seciton type, followed by a header and the section content. This
overall structure is illustrated in
Figure~\ref{fig:anlzFileStructure}, and the structure of the known tag
types is described next.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{\tt PMAI} & \bitbox{4}{$len\_header$} & \bitbox{4}{$len\_file$} & \bitbox{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{12}{} & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \wordbox[lr]{1}{Tagged Sections} \\
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Analysis File Structure}
  \label{fig:anlzFileStructure}
\end{figure}

\subsection{Analysis File Sections}

The structure of each tagged section has an ``envelope'' that can be
understood even if the internal structure of the section is unknown,
making it easy to navigate through the file looking for the section
you need. This structure is very similar to the file itself, and is
illustrated in Figure~\ref{fig:anlzTagStructure}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$fourcc$} & \bitbox{4}{$len\_header$} & \bitbox{4}{$len\_tag$} & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \wordbox[lr]{1}{Tag-Specific Content}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Tagged Section Structure}
  \label{fig:anlzTagStructure}
\end{figure}

Every section begins with a four-character code, $fourcc$, identifying
its specific structure and content, as described in the sections
below. This is followed by a four-byte value, $len\_header$, which
specifies how many bytes there are in the section header, and another
four-byte value, $len\_tag$, which specifies the length of the entire
tagged section (including the header), in bytes. This value can be
added to the address of the start of the tag to find the start of the
next tag.

There is not much value to $len\_header$. If you study the structure
of each type of tagged section, you can see some sense of where the
``header-like stuff'' ends, and ``content-like stuff'' begins, and
this seems to line up with the value of $len\_header$. But because
there are important values in each tag's header, and those always
start immediately after $len\_tag$, it is simply easier to ignore
$len\_header$, and model the tag body as beginning at byte~{\tt 0c} of
the tag.

To be continued...

\section{Crate Digger}

You can find a Java library that can parse the structures described in
this research, and that can retrieve them from players' NFS servers,
at: \url{https://github.com/deep-symmetry/crate-digger}

The project also contains Kaitai Struct specifications for the file
structures, which were used to automatically generate Java classes to
parse them, and which can be used to generate equivalent code for a
variety of other programming languages.

There are also ONC RPC specification files which were similarly used
to generate Java classes to communicate with the NFSv2 servers in the
players, and which can likely be used to generate structures for other
languages as well.

\begin{appendix}

  \addcontentsline{toc}{section}{\listfigurename}
  \listoffigures

  \addcontentsline{toc}{section}{\listtablename}
  \listoftables

  \begin{center}
    \begin{samepage}
      \includegraphics[width=4cm]{assets/DS-Logo-bw-4k}

      \vspace{0.25cm}
      \url{http://deepsymmetry.org}
    \end{samepage}
  \end{center}

\end{appendix}

\end{document}
