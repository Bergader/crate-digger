\documentclass[11pt]{article}

\usepackage{ifxetex}
\ifxetex
    % XeLaTeX
    \usepackage{polyglossia}
    \setmainlanguage[]{english}
    \usepackage{fontspec}
    \usepackage[]{unicode-math}
    %\setmainfont{Hoefler Text}
    \setmainfont{Garamond Premier Pro}
    \setmonofont{Andale Mono}
    %\setmathfont
    %    [ Extension = .otf,
    %      BoldFont = *bold,
    %    ]{xits-math}
\else
    % default: pdfLaTeX
    \usepackage[utf8]{inputenc}
    \usepackage[english]{babel}
    \usepackage{courier}
    %\usepackage[babel=true]{microtype}
\fi

\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\usepackage{bytefield}
\usepackage{bookmark}
\usepackage{color}
\usepackage{alltt}
\usepackage{tabu, booktabs}
\usepackage{longtable}
\usepackage{hyperxmp}
\hypersetup{%
  pdfcontactemail={james@deepsymmetry.org},
  pdfcontacturl={http://deepsymmetry.org},
  pdflang={en},
  pdfmetalang={en}
}
\usepackage{hyperref}

\newcommand{\rmst}{{\it\small rmst}}

\title{Rekordbox Export Structure Analysis}
\author{James Elliott \\Deep Symmetry, LLC}

\begin{document}

\maketitle

\abstract{The files written to external media by rekordbox for use in
  player hardware contain a wealth of information that can be used in
  place of queries to the remotedb server on the players, which is
  important because they can be obtained from the players' NFS
  servers, even if there are four players in use sharing the same
  media. Under those circumstances, remotedb queries are impossible.
  This article documents what has been learned so far about the
  files, and how to interpret them.}

\pagestyle{headings}

%% Define macros used to draw more complex message byte fields with
%% labeled headers and color-related sections.

\newcommand\hexhead{
  \bitbox[]{1}{\tiny\bfseries 0}
  \bitbox[]{1}{\tiny\bfseries 1}
  \bitbox[]{1}{\tiny\bfseries 2}
  \bitbox[]{1}{\tiny\bfseries 3}
  \bitbox[]{1}{\tiny\bfseries 4}
  \bitbox[]{1}{\tiny\bfseries 5}
  \bitbox[]{1}{\tiny\bfseries 6}
  \bitbox[]{1}{\tiny\bfseries 7}
  \bitbox[]{1}{\tiny\bfseries 8}
  \bitbox[]{1}{\tiny\bfseries 9}
  \bitbox[]{1}{\tiny\bfseries a}
  \bitbox[]{1}{\tiny\bfseries b}
  \bitbox[]{1}{\tiny\bfseries c}
  \bitbox[]{1}{\tiny\bfseries d}
  \bitbox[]{1}{\tiny\bfseries e}
  \bitbox[]{1}{\tiny\bfseries f}
}

\newcommand{\baselinealign}[1]{%
  \centering
  \strut#1%
}

\newcommand{\colorbitbox}[4][rlbt]{%
  \sbox0{\bitbox[#1]{#3}{#4}}%
 \makebox[0pt][l]{\textcolor{#2}{\rule[-\dp0]{\wd0}{\ht0}}}%
 \bitbox[#1]{#3}{#4}%
}

\definecolor{lightgreen}{rgb}{0.64,1,0.71}
\definecolor{yellow}{rgb}{1,1,0.71}
\definecolor{lightred}{rgb}{1,0.7,0.71}
\definecolor{lightcyan}{rgb}{0.84,1,1}
\definecolor{lightpurple}{rgb}{1,0.71,1}

\tableofcontents

\newpage

\section{Database Exports}

The starting point for finding track metadata from a player is the
database export file, which can be found within rekordbox media at the
following path:

\begin{center}
  {\tt /PIONEER/rekordbox/export.pdb}
\end{center}

(If you are using the Crate Digger {\tt FileFetcher} to request this
file, use that path as the {\tt filePath} argument, and use a {\tt
  mountPath} value of {\tt /B/} if you want to read it from the SD
slot, or {\tt /C/} to obtain it from the USB slot).

The file is a relational database format designed to be efficiently
used by very low power devices (there were deployments on 16 bit
devices with 32K of RAM). Today you are most likely to encounter it
within the Pioneer Professional DJ ecosystem, because it is the format
that their rekordbox software uses to write USB and SD media which can
be mounted in DJ controllers and used to play and mix music.

The file consists of a series of fixed size pages. The first page
contains a file header which defines the page size and the locations
of database tables of different types, by the index of their first
page. The rest of the pages consist of the data pages for all of the
tables identified in the header.

Each table is made up of a series of rows which may be spread across
any number of pages. The pages start with a header describing the page
and linking to the next page. The rest of the page is used as a heap:
rows are scattered around it, and located using an index structure
that builds backwards from the end of the page. Each row of a given
type has a fixed size structure which links to any variable-sized
strings by their offsets within the page.

As changes are made to the table, some records may become unused, and
there may be gaps within the heap that are too small to be used by
other data. There is a bit map in the row index that identifies which
rows are actually present. Rows that are not present must be ignored:
they do not contain valid (or even necessarily well-formed) data.

The majority of the work in reverse-engineering this format was
performed by Henry
Betts\footnote{\url{https://github.com/henrybetts/Rekordbox-Decoding}}
and Fabian
Lesniak\footnote{\url{https://github.com/flesniak/python-prodj-link}},
to whom I am hugely grateful.

\subsection{File Header}
\label{sec:fileHeader}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{4}{$len\_page$} &
      \bitbox{4}{$num\_tables$} & \bitbox{4}{$next_u$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown$} & \bitbox{4}{$sequence$} & \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} &
      & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \wordbox[lr]{1}{Table Pointers} \\
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{File Header}
  \label{fig:fileHeader}
\end{figure}

Unless otherwise stated, all multi-byte numbers in the file are stored
in little-endian byte order. Field names used in the Figures match the
IDs assigned to them in the Kaitai Struct
specification\footnote{\url{https://github.com/Deep-Symmetry/crate-digger/blob/master/src/main/kaitai/rekordbox_pdb.ksy}},
unless that is too long to fit, in which case a subscripted
abbreviation is used, and the text will mention the actual struct
field name.

The first page begins with the file header, shown in
Figure~\ref{fig:fileHeader}. The header starts with four zero bytes,
followed by a four-byte integer, $len\_page$ at byte~{\tt 04}, that
establishes the size of each page (including this first one), in
bytes. This is followed by another four-byte integer, $num\_tables$ at
byte~{\tt 08}, which reports the number of different tables that are
present in the file. Each table will have a table pointer entry in the
``Table pointers'' section of the file header, described below, that
identifies and locates the table.

The four-byte integer $next_u$ at byte~{\tt 0c} has an unknown
purpose, but Mr. Lesniak named it next\_unused\_page and said
``Not used as any empty\_candidate, points past the end of the
file.'' The four-byte integer $sequence$, at byte~{\tt 14}, was
described ``Always incremented by at least one, sometimes by two or
three.'' and I assume this means it reflects a version number that
rekordbox updates when synchronizing to the exported media.

Finally, there is another series of four zero bytes, and then the
header ends with the list of table pointers which begins at byte~{\tt
  1c}. There are as many of these as specified by $num\_tables$, and
each has the structure shown in Figure~\ref{fig:tablePointer}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$type$} & \bitbox{4}{$empty_c$} & \bitbox{4}{$first\_page$} & \bitbox{4}{$last\_page$}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{Table Pointer}
  \label{fig:tablePointer}
\end{figure}

Each Table Pointer is a series of four four-byte integers. The first,
$type$, identifies the type of table being defined. The known table
types are shown in Table~\ref{table:tableTypes}. The second value, at
byte~{\tt 04} of the Table Pointer, was called $empty\_candidate$
by Mr. Lesniak. It may link to a chain of empty pages if the database
is ever garbage collected, but this is speculation on my part.

\begin{longtabu}{rlX}
  \toprule
  {\bfseries Type} & {\bfseries Name} & {\bfseries Row Content} \endhead

  \bottomrule \\
  \caption{Table Types} \endfoot

  0 & tracks & Track metadata: title, artist, genre, artwork ID,
  playing time, etc.,
  Section~\ref{sec:trackRows}. \label{table:tableTypes} \\

  1 & genres & Musical genres, for reference by tracks and searching,
  Section~\ref{sec:genreRows}. \\

  2 & artists & Artists, for reference by tracks and searching,
  Section~\ref{sec:artistRows}. \\

  3 & albums & Albums, for reference by tracks and searching,
  Section~\ref{sec:albumRows}. \\

  4 & labels & Music labels, for reference by tracks and searching,
  Section~\ref{sec:labelRows}. \\

  5 & keys & Musical keys, for reference by tracks, searching, and key
  matching, Section~\ref{sec:keyRows}. \\

  6 & colors & Color labels, for reference by tracks and searching,
  Section~\ref{sec:colorRows}. \\

  7 & playlist\_tree & Describes the hierarchical tree structure of
  available playlists and folders grouping them,
  Section~\ref{sec:playlistTreeRows}. \\

  8 & playlist\_entries & Links tracks to playlists, in the right
  order, Section~\ref{sec:playlistEntryRows}. \\

  13 & artwork & File paths of album artwork images,
  Section~\ref{sec:artworkRows}. \\

  16 & columns & Details not yet confirmed. \\

  19 & history & Records the tracks played during performances. \\

\end{longtabu}

Other than the type, the two important values are $first\_page$ at
byte~{\tt 08} and $last\_page$ at byte~{\tt 0c}. These tell us how to
find the table. They are page indices, where the page containing the
file header has index 0, the page with index 1 begins at
byte~$len\_page$, and so on. In other words, the first page of the
table identified by the current Table Pointer can be found within the
file starting at the byte $len\_page \times first\_page$.

The table is a linked list of pages: each page contains the index of
the next page after it. However, you need to keep track of the
$last\_page$ value for the table, because it tells you not to try to
follow the next page link once you reach the page with that index. (If
you do keep going, you will start reading pages of some different
table.) The structure of the table pages themselves are described
in the next section.

As far as we know, the remainder of the first page after the table
pointers is unused.


\subsection{Table Pages}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\

    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitboxes*{1}{{\tt 00} {\tt 00} {\tt 00} {\tt 00}} & \bitbox{4}{$page\_index$} &
      \bitbox{4}{$type$} & \bitbox{4}{$next\_page$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown_1$} & \bitbox{4}{$unknown_2$} & \bitbox{1}{$n_{rs}$} & \bitbox{1}{$u_3$} &
      \bitbox{1}{$u_4$} & \bitbox{1}{$p_f$} & \bitbox{2}{$free_s$} & \bitbox{2}{$used_s$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{2}{$u_5$} & \bitbox{2}{$num_{rl}$} & \bitbox{2}{$u_6$} & \bitbox{2}{$u_7$} &
      \bitbox[lrt]{8}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \wordbox[lr]{1}{$heap$} \\
      \skippedwords \\
      \wordbox[lr]{1}{$row\_groups$} \\
      \bitbox[lb]{6}{} & \bitbox[]{2}{\ldots} &
      \bitbox{2}{$ofs_{17}$} & \bitbox{2}{$ofs_{16}$} & \bitbox{2}{$row_{pf_1}$} & \bitbox{2}{$ofs_{15}$} \\
      \bitbox{2}{$ofs_{14}$} & \bitbox{2}{$ofs_{13}$} & \bitbox{2}{$ofs_{12}$} & \bitbox{2}{$ofs_{11}$} &
      \bitbox{2}{$ofs_{10}$} & \bitbox{2}{$ofs_{9}$} & \bitbox{2}{$ofs_{8}$} & \bitbox{2}{$ofs_{7}$} \\
      \bitbox{2}{$ofs_{6}$} & \bitbox{2}{$ofs_{5}$} & \bitbox{2}{$ofs_{4}$} & \bitbox{2}{$ofs_{3}$} &
      \bitbox{2}{$ofs_{2}$} & \bitbox{2}{$ofs_{1}$} & \bitbox{2}{$ofs_{0}$} & \bitbox{2}{$row_{pf_0}$}
    \end{leftwordgroup}

  \end{bytefield}
  \caption{Table Page}
  \label{fig:tablePage}
\end{figure}

The table header is followed by the table pages themselves. These each
have the size specified by $len\_page$ in Figure~\ref{fig:fileHeader},
and the structure shown in Figure~\ref{fig:tablePage}.

Data pages all seem to have the header structure described here, but
not all of them actually store data. Some of them are ``strange'' and
we have not yet figured out why. The discussion below describes how to
recognize a strange page, and avoid trying to read it as a data page.

The first four bytes of a table page always seem to be zero. This is
followed by a four-byte value $page\_index$ which identifies the index
of this page within the list of table pages (the header has index 0,
the first actual data page the index 1, and so on). This value seems
to be redundant, because it can be calculated by dividing the offset
of the start of the page by $len\_page$, but perhaps it serves as a
sanity check.

This is followed by another four-byte value, $type$, which identifies
the type of the page, using the values shown in
Table~\ref{table:tableTypes}. This again seems redundant because the
table header which was followed to reach this page also identified the
table type, but perhaps it is another sanity check, or an alternate
way to tell, when following page links, that you have reached the end
of the table you are interested in. Speaking of which, the next
four-byte value, $next\_page$, is that link: it identifies the index
at which the next page of this table can be found, as long as we have
not already reached the final page of the table, as described in
Section~\ref{sec:fileHeader}.

The exact meaning of $unknown_1$ is unclear. Mr. Flesinak said
``sequence number (0$\rightarrow$1: 8$\rightarrow$13, 1$\rightarrow$2:
22, 2$\rightarrow$3: 27)'' but I don't know how to interpret that.
Even less is known about $unknown_2$. But $num\_rows\_small$ at
byte~{\tt 18} within the page (abbrviated $n_{rs}$ in
Figure~\ref{fig:tablePage}) holds the number of rows that are present
in the page, unless $num\_rows\_large$ (below) holds a value that is
larger (but not equal to {\tt 1fff}). This seems like a strange
mechanism for dealing with the fact that some tables (like playlist
entries) have a lot of very small rows, too many to count with a
single byte. But then why not just always use $num\_rows\_large$?

The purpose of the next two bytes are is also unclear. Of $u_3$ Mr.
Flesniak said ``a bitmask (first track: 32)'', and he described $u_4$
as often 0, sometimes larger, especially for pages with a high number
of rows (e.g. 12 for 101 rows).

Byte~{\tt 1b} is called $page\_flags$ (abbrviated $p_f$ in
Figure~\ref{fig:tablePage}). According to Mr. Flesniak, ``strange''
(non-data) pages will have the value {\tt 44} or {\tt 64}, and other
pages have had the values {\tt 24} or {\tt 34}. Crate Digger considers
a page to be a data page if $page\_flags \& {\tt 40} = {\tt 0}$.

Bytes~{\tt 1c-1d} are called $free\_size$ (abbreviated $free_s$ in
Figure~\ref{fig:tablePage}), and store the amount of unused space in
the page heap (excluding the row index which is built backwards from
the end of the page); $used\_size$ at bytes~{\tt 1c-1d} (abbreviated
$used_s$) stores the number of bytes that are in use in the page heap.

Bytes~{\tt 20-21}, $u_5$, are of unclear purpose. Mr. Flesniak labeled
them ``(0$\rightarrow$1: 2).''

Bytes~{\tt 20-21}, $num\_rows\_large$ (abbrviated $num_{rl}$ in
Figure~\ref{fig:tablePage}) hold the number of entries in the row
index at the end of the page when that value is too large to fit into
$num\_rows\_small$ (as mentioned above), and that situation seems to
be indicated when this value is larger than $num\_rows\_small$, but
not equal to {\tt 1fff}.

$u_6$ at bytes~{\tt 24-25} seems to have the value {\tt 1004} for
strange pages, and {\tt 0000} for data pages. And Mr. Flesniak
describes $u_7$ at bytes~{\tt 26-27} as ``always 0 except 1 for
history pages, num entries for strange pages?''

After these header fields comes the page heap. Rows are allocated
within this heap starting at byte~{\tt 28}. Since rows can be
different sizes, there needs to be a way to locate them. This takes
the form of a row index, which is built from the end of the page
backwards, in groups of up to sixteen row pointers along with a
bitmask saying which of those rows are still part of the table (they
might have been deleted).

The number of row index entries is determined, as described above, by
the value of either $num\_rows\_small$ or $num\_rows\_large$.

The bit mask for the first group of up to sixteen rows, labeled
$row_{pf_0}$ in Figure~\ref{fig:tablePage} (meaning ``row presence
flags group 0''), is found in the last two bytes of the page. The low
order bit of this value will be set if row 0 is really present, the
next bit if row 1 is really present, and so on. The two bytes before
these flags, labeled $ofs_0$, store the offset of the first row in the
page. This offset is the number of bytes past the end of the page
header at which the row itself can be found. So if row 0 begins at the
very beginning of the heap, at byte~{\tt 28} in the page, $ofs_0$
would have the value {\tt 0000}.

As more rows are added to the page, space is allocated for them in the
heap, and additional index entries are added at the end of the heap,
growing backwards. Once there have been sixteen rows added, all of the
bits in $row_{pf_0}$ are accounted for, and when another row is added,
before its offset entry $ofs_{16}$ can be added, another row bit-mask
entry $row_{pf_1}$ needs to be allocated. And so the row index grows
backwards towards the rows that are being added forwards, and once
they are too close for a new row to fit, the page is full, and another
page gets allocated to the table.

\subsection{Table Rows}

The structure of the rows themselves is determined by the $type$ of
the table, using the values shown in Table~\ref{table:tableTypes}.

\subsubsection{Album Rows}
\label{sec:albumRows}

Album rows hold an album name and ID along with an artist association,
with the structure shown in Figure~\ref{fig:albumRow}. The unknown
value at bytes~{\tt 00-01} seems to usually have the values {\tt 80
  00}. It is followed by a two-byte value Mr. Flesniak called
$index\_shift$, although I don't know what that means, and another
four bytes of unknown purpose. But at bytes~{\tt 08-0b} we finally
find a value we have a use for: $artist\_id$ holds the ID of an artist
row associated with this track row. This is followed by $id$, the ID
of this track row itself, at bytes~{\tt 0c-0f}. We assume that there
are index tables somewhere that would let us locate the page and row
index of a record given its table type and ID, but we have not yet
found and figured them out.

This is followed by five more bytes with unknown meaning, and the
final byte in the row, $ofs\_name$ is a pointer to the track name
(labeled $o_n$ in Figure~\ref{fig:albumRow}. To find the location of
the name, add $ofs\_name$ bytes to the address of the start of the
track row itself. The name itself is encoded in a surprisingly baroque
way, explained in Section~\ref{sec:deviceSqlStrings}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{2}{$u_1$} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$unknown_2$} &
      \bitbox{4}{$artist\_id$} & \bitbox{4}{$id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$unknown_3$} & \bitbox{1}{$u_4$} & \bitbox{1}{$o_n$} &
      \bitbox[lt]{10}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Album Row}
  \label{fig:albumRow}
\end{figure}

\subsubsection{Artist Rows}
\label{sec:artistRows}

Artist rows hold an Artist name and ID, with the structure shown in
Figure~\ref{fig:artistRowNear} or Figure~\ref{fig:artistRowFar}. The
$subtype$ value at bytes~{\tt 00-01} determines which variant is used.
If the artist name was allocated close enough to the row to be reached
by a single byte offset, offset, $subtype$ has the value {\tt 0060},
and the row has the structure in Figure~\ref{fig:artistRowNear}. If
the name is too far away for that, $subtype$ has the value {\tt 0064}
and the row has the structure in Figure~\ref{fig:artistRowFar}.

In either case, $subtype$ is followed by the unexplained two-byte
value found in many row types that Mr. Flesniak called $index\_shift$,
and then by $id$, the ID of this artist row itself, at bytes~{\tt
  04-07}, an unknown value at byte~{\tt 08}, and $ofs\_name\_near$ at
byte~{\tt 09} (labeled $o_n$ in Figure~\ref{fig:artistRowNear}), the
one-byte name offset used only in the first variant.

If $subtype$ is {\tt 0064}, the value of $ofs\_name\_near$ is ignored,
and instead the two-byte value $ofs\_name\_far$ (labeled $o_{far}$ in
Figure~\ref{fig:artistRowFar}) is used.

Whichever name offset is used, it is a pointer to the artist name. To
find the location of the name, add the value of the offset to the
address of the start of the artist row itself. This gives the address
of a DeviceSQL string holding the name, with the structure explained
in Section~\ref{sec:deviceSqlStrings}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{2}{\tt 0060} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$id$} &
    \bitbox{1}{$u_1$} & \bitbox{1}{$o_n$} & \bitbox[]{6}{}
  \end{bytefield}
  \caption{Artist Row with Nearby Name}
  \label{fig:artistRowNear}
\end{figure}

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{2}{\tt 0064} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$id$} &
    \bitbox{1}{$u_1$} & \bitbox{1}{$o_n$} & \bitbox{2}{$o_{far}$} & \bitbox[]{4}{}
  \end{bytefield}
  \caption{Artist Row with Far Name}
  \label{fig:artistRowFar}
\end{figure}

\subsubsection{Artwork Rows}
\label{sec:artworkRows}

Artwork rows hold an $id$ (which tracks refer to) and the path at
which the corresponding album art image file can be found, with the
structure shown in Figure~\ref{fig:artworkRow}. Note that in this
case, the DeviceSQL string $path$ is embedded directly into the row
itself, rather than being located elsewhere in the heap through an
offset. The structure of the string itself is still as described in
Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$id$} & \bitbox[lrt]{12}{$path$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Artwork Row}
  \label{fig:artworkRow}
\end{figure}

\subsubsection{Color Rows}
\label{sec:colorRows}

Color rows hold a numeric color $id$ (which controls the actual color
displayed on the player interface) at bytes~{\tt 05-06} and a text
label or $name$ starting at byte~{\tt 08} which is a DeviceSQL string
shown in the information panel for tracks that are assigned the color.
The rows have the structure shown in Figure~\ref{fig:colorRow}. There
are several bytes in the row that are not yet known to have any
meaning. The structure of $name$ is described in
Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$unknown_1$} & \bitbox{1}{$u_2$} & \bitbox{2}{$id$} & \bitbox{1}{$u_3$} & \bitbox[lrt]{8}{$name$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Color Row}
  \label{fig:colorRow}
\end{figure}

\subsubsection{Genre Rows}
\label{sec:genreRows}

Genre rows hold a numeric genre $id$ (which tracks can be assigned) at
bytes~{\tt 00-03} and a text $name$ starting at byte~{\tt 04} which is
a DeviceSQL string. The rows have the structure shown in
Figure~\ref{fig:genreRow}. The structure of $name$ is described in
Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$id$} & \bitbox[lrt]{12}{$name$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Genre or Label Row}
  \label{fig:genreRow}
\end{figure}

\subsubsection{Key Rows}
\label{sec:keyRows}

Key rows represent musical keys. They hold a numeric $id$ (which
tracks can be assigned) at bytes~{\tt 00-03} and a text $name$
starting at byte~{\tt 08} which is a DeviceSQL string. (There seems to
be a second copy of the ID at bytes~{\tt 04-07}.) The rows have the
structure shown in Figure~\ref{fig:keyRow}. The structure of $name$ is
described in Section~\ref{sec:deviceSqlStrings}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$id$} & \bitbox{4}{$id2$} & \bitbox[lrt]{8}{$name$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Key Row}
  \label{fig:keyRow}
\end{figure}

\subsubsection{Label Rows}
\label{sec:labelRows}

Label rows represent record labels. They hold a numeric $id$ (which
tracks can be assigned) at bytes~{\tt 00-03} and a text $name$
starting at byte~{\tt 04} which is a DeviceSQL string. The rows have
the structure shown in Figure~\ref{fig:genreRow}. The structure of
$name$ is described in Section~\ref{sec:deviceSqlStrings}.

\subsubsection{Playlist Tree Rows}
\label{sec:playlistTreeRows}

Playlist tree rows are used to organize the hierarchical structure of
the playlist menu. There is probably an index somewhere that makes it
possible to find the right rows directly when loading a playlist, but
we have not yet figured out how indices work in DeviceSQL databases,
so Crate Digger simply reads all the rows and builds its own in-memory
index of the tree.

Playlist tree rows can either represent a playlist ``folder'' which
contains other folders and playlists, or a regular playlist which
holds only tracks. The rows are identified by an $id$ at bytes~{\tt
  0c-0f}, and also contain a $parent\_id$ at bytes~{\tt 00-03} which
is how the hierarchical structure is represented: the contents of a
folder are the other rows in this table whose $parent\_id$ folder is
equal to the $id$ of the folder.

Similarly, the tracks that make up a regular playlist are the Playlist
Entry Rows (described in Section~\ref{sec:playlistEntryRows}) whose
$playlist\_id$ is equal to this row's $id$.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$parent\_id$} & \bitbox{4}{} & \bitbox{4}{$sort\_order$} & \bitbox{4}{$id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$raw\_is\_folder$} & \bitbox[lrt]{12}{name}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Playlist Tree Row}
  \label{fig:playlistTreeRow}
\end{figure}

Each playlist tree row also has a text $name$ starting at byte~{\tt
  14} which is a DeviceSQL string displayed when navigating the
hierarchy, a $sort\_order$ indicator at bytes~{\tt 08-0b} (this may be
the same value used to select sort orders when requesting menus using
the {\tt dbserver} protocol, shown in Table~7 of the dysentery
Protocol Analysis paper, but this has not yet been confirmed), and a
value that specifies whether the row defines a folder or a playlist.
In the Kaitai Struct, this value is called $raw\_is\_folder$, is found
at bytes~{\tt 10-13}, and has a non-zero value for folders. For
convenience, the struct also defines a derived value, $is\_folder$,
which is a boolean.

The rows have the structure shown in Figure~\ref{fig:playlistTreeRow}.
The structure of $name$ is described in
Section~\ref{sec:deviceSqlStrings}.

\subsubsection{Playlist Entry Rows}
\label{sec:playlistEntryRows}

Playlist entry rows list the tracks that belong to a particular
playlist, and also establish the order in which they should be played.
They have a very simple structure, shown in
Figure~\ref{fig:playlistEntryRow}, containing only three values. The
$entry\_index$ at bytes~{\tt 00-03} specifies the position within the
playlist at which this entry belongs. The $track\_id$ at bytes~{\tt
  04-07} identifies the track to be played at this position in the
playlist, by corresponding to the $id$ of a row in the Track table
described in Section~\ref{sec:trackRows}, and the $playlist\_id$ at
bytes~{\tt 08-0b} identifies the playlist to which it belongs, by
corresponding to the $id$ of a row in the Playlist Tree described in
Section~\ref{sec:playlistTreeRows}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{4}{$entry\_index$} & \bitbox{4}{$track\_id$} & \bitbox{4}{$playlist\_id$} & \bitbox[]{4}{}
  \end{bytefield}
  \caption{Playlist Entry Row}
  \label{fig:playlistEntryRow}
\end{figure}

\subsubsection{Track Rows}
\label{sec:trackRows}

Track rows describe audio tracks that can be played from the media
export, and provide many details about the music including links to
other tables like artists, albums, keys, and others. They have the
structure shown in Figure~\ref{fig:trackRow}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{2}{$u_1$} & \bitbox{2}{$i_{shift}$} & \bitbox{4}{$bitmask$} & \bitbox{4}{$sample\_rate$} &
      \bitbox{4}{$composer\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{4}{$file\_size$} & \bitbox{4}{$u_2$} & \bitbox{2}{$u_3$} & \bitbox{2}{$u_4$} &
      \bitbox{4}{$artwork\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{4}{$key\_id$} & \bitbox{4}{$orig\_artist\_id$} & \bitbox{4}{$label\_id$} & \bitbox{4}{$remixer\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 30}
      \bitbox{4}{$bitrate$} & \bitbox{4}{$track\_number$} & \bitbox{4}{$tempo$} & \bitbox{4}{$genre\_id$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 40}
      \bitbox{4}{$album\_id$} & \bitbox{4}{$artist\_id$} & \bitbox{4}{$id$} & \bitbox{2}{$disc_n$} &
      \bitbox{2}{$play_c$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 50}
      \bitbox{2}{$year$} & \bitbox{2}{$s_{depth}$} & \bitbox{2}{$dur$} & \bitbox{2}{$u_5$} &
      \bitbox{1}{$c_{id}$} & \bitbox{1}{$r$} & \bitbox{2}{$u_6$} & \bitbox{2}{$u_7$} & \bitbox{2}{$ofs_0$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 60}
      \bitbox{2}{$ofs_1$} & \bitbox{2}{$ofs_2$} & \bitbox{2}{$ofs_3$} & \bitbox{2}{$ofs_4$} &
      \bitbox{2}{$ofs_5$} & \bitbox{2}{$ofs_6$} & \bitbox{2}{$ofs_7$} & \bitbox{2}{$ofs_8$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 70}
      \bitbox{2}{$ofs_9$} & \bitbox{2}{$ofs_{10}$} & \bitbox{2}{$ofs_{11}$} & \bitbox{2}{$ofs_{12}$} &
      \bitbox{2}{$ofs_{13}$} & \bitbox{2}{$ofs_{14}$} & \bitbox{2}{$ofs_{15}$} & \bitbox{2}{$ofs_{16}$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 70}
      \bitbox{2}{$ofs_{17}$} & \bitbox{2}{$ofs_{18}$} & \bitbox{2}{$ofs_{19}$} & \bitbox{2}{$ofs_{20}$} & \bitbox[]{8}{}
    \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Track Row}
  \label{fig:trackRow}
\end{figure}

The first two bytes, labeled $u_1$, have an unknown purpose; they
usually are {\tt 24} followed by {\tt 00}. They are followed by the
unexplained two-byte value found in many row types that Mr. Flesniak
called $index\_shift$, and a four-byte value he called $bitmask$,
although we do not know what the bits mean. The value at bytes~{\tt
  08-0b}, $sample\_rate$, is the first one we have a solid
understanding of: it holds the playback sample rate of the audio file,
in samples per second.

Bytes~{\tt 0c-0f} hold the value $composer\_id$ which identifies the
composer of the track, if known, as a non-zero $id$ value of an Artist
row, as discussed in Section~\ref{sec:artistRows}. The size of the
audio file, in bytes, is found in $file\_size$ at bytes~{\tt 10-13}.
This is followed by an unknown four-byte value, $u_2$, which may be
another ID, and two unknown two-byte values, $u_3$ (about which Mr.
Flesniak says ``always 19048?'') and $u_4$ (``always 30967?'').

If there is cover art for the track, there will be a non-zero value in
$artwork\_id$ (bytes~{\tt 1c-1f}), identifying the $id$ of an Artwork
row, as discussed in section~\ref{sec:artworkRows}.

If a dominant musical key was identified for the track there will be a
non-zero value in $key\_id$ (bytes~{\tt 20-23}), which represents the
$id$ of a Key row, as discussed in Section~\ref{sec:keyRows}. If the
track is known to be a remake, the non-zero Artist row $id$
(Section~\ref{sec:artistRows}) of the original performer will be found
at bytes~{\tt 24-27} in $original\_artist\_id$. If there is a known
record label for the track, the non-zero value in $label\_id$ will
link to the $id$ of a Label row $id$ as described in
Section~\ref{sec:labelRows}. Similarly, if there is a known remixer,
there will be a non-zero value in $remixer\_id$ (bytes~{\tt 2c-2f})
linking to the $id$ of an Artist row (Section~\ref{sec:artistRows}).

The field $bitrate$ at bytes~{\tt 30-33} stores the playback bit rate
of the track, and $track\_number$ at bytes~{\tt 34-37} holds the
position of the track within its album. $tempo$ at bytes~{\tt 38-3b}
holds the playback tempo of the start of the track in beats per
minute, multiplied by 100 (in order to support a precision of
$\frac{1}{100}$ BPM). If there is a known genre for the track, there
will be a non-zero value in $genre\_id$ at bytes~{\tt 3c-3f},
representing the $id$ of a Genre row as discussed in
Section~\ref{sec:genreRows}.

If the track is part of an album, there will be a non-zero value in
$album\_id$ at bytes~{\tt 40-43}, and this will be the $id$ of an
Album row as discussed in Section~\ref{sec:albumRows}. The Artist row
$id$ (Section~\ref{sec:artistRows}) of the primary performer
associated with the track is found in $artist\_id$ at bytes~{\tt
  44-47}. And the $id$ of the track itself is found in $id$ at
bytes~{\tt 48-4b}. If the album is known to consist of multiple discs,
the disc number on which this track is found will be in $disc\_number$
at bytes~{\tt 4c-4d}. And the number of times the track has been
played is found in $play\_count$ (bytes~{\tt 4e-4f}).

The year in which the track was recorded, if known, is in $year$ at
bytes~{\tt 50-51}. The sample depth of the track audio file (bits per
sample) is in $sample\_depth$ at bytes~{\tt 52-53}. The playback time
of the track (in seconds, at normal speed) is in $duration$ at
bytes~{\tt 54-55}. The purpose of the next two bytes, labeled $u_5$,
is unknown, they seem to always hold the value 41.

Byte~{\tt 58}, $color\_id$ (labeled $c_{id}$ in
Figure~\ref{fig:trackRow}), holds the color assigned to the track in
rekordbox, as the $id$ of a Color row (described in
Section~\ref{sec:colorRows}), or zero if no color has been assigned.
Byte~{\tt 59}, $rating$ (labeled $r$ in Figure~\ref{fig:trackRow})
holds the rating (0 to 5 stars) assigned the track. The next two
bytes, labeled $u_6$, have an unknown purpose, and seem to always have
the value 1. The two bytes after them, labeled $u_7$, are also
unknown; Mr. Flesniak said ``alternating 2 and 3''.

The rest of the track row is an array of 21 two-byte offsets that
point to DeviceSQL strings. To find the start of the string, add the
address of the start of the track row to the offset. The purpose of
each string is described in Table~\ref{table:trackStrings}, and the
structure of the strings themselves is explained in
Section~\ref{sec:deviceSqlStrings}.

For convenience, the strings can be accessed as Kaitai Struct instance
values with the names shown in the table.

\begin{longtabu}{rlX}

  \toprule
  {\bfseries Index} & {\bfseries Name} & {\bfseries Content} \endhead

  \bottomrule \\
  \caption{Track Offset Strings} \endfoot

  0 & $unknown\_string\_1$ \label{table:trackStrings} & Unknown, so far always empty. \\

  1 & $texter$ & Unknown, named by {\tt @flesniak}. \\

  2 & $unknown\_string\_2$ & Unknown, ``thought track number, wrong''. \\

  3 & $unknown\_string\_3$ & Unknown, ``Strange
  strings.''\footnote{Often zero length, sometimes low binary values,
    ASCII {\tt 01} or {\tt 02} as content.}. \\

  4 & $unknown\_string\_4$ & ``Strange strings'' (as above). \\

  5 & $messsage$ & Unknown, named by {\tt @flesniak}. \\

  6 & $kuvo\_public$ & Empty or {\tt "ON"}.\footnote{Apparently
    used rather than a simple bit flag to control whether the track
    information is visible on Kuvo.} \\

  7 & $autoload\_hotcues$ & Empty or {\tt
    "ON"}.\footnote{Apparently used rather than a simple bit flag to
    control whether hot cues are automatically loaded for the track.}
  \\

  8 & $unknown\_string\_5$ & Unknown. \\

  9 & $unknown\_string\_6$ & Unknown, usually empty. \\

  10 & $date\_added$ & When track was added to collection. \\

  11 & $release\_date$ & When track was released. \\

  12 & $mix\_name$ & Name of the track remix. \\

  13 & $unknown\_string\_7$ & Unknown, usually empty. \\

  14 & $analyze\_path$ & File path of track analysis, see
  Section~\ref{sec:analysisFiles}. \\

  15 & $analyze\_date$ & When track analysis was performed. \\

  16 & $comment$ & Track comment assigned by DJ. \\

  17 & $title$ & Track title. \\

  18 & $unknown\_string\_8$ & Unknown, usually empty. \\

  19 & $filename$ & Name of track audio file. \\

  20 & $file\_path$ & File path of track audio. \\

\end{longtabu}

\subsection{DeviceSQL Strings}
\label{sec:deviceSqlStrings}

Many row types store string values, sometimes by directly embedding
them, but more often by storing an offset to a location elsewhere in
the heap. In either case the string itself uses the strange structure
described in this section. Strings can be stored in a variety of
formats. The first byte of the structure, labeled $length\_and\_kind$
in the parsed Kaitai Struct, identifies the encoding type and, when
the value is odd, also the length (for short ASCII strings), as
detailed in Section~\ref{sec:shortAscii}.

\subsubsection{Long ASCII Strings}

If $length\_and\_kind$ has the value {\tt 40}, it is followed by a
two-byte $length$ field, and then followed by that many bytes of
ASCII-encoded string data, as shown in Figure~\ref{fig:longAscii}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{1}{\tt 40} & \bitbox{2}{$length$} & \bitbox[lrt]{13}{ASCII data}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Long ASCII DeviceSQL String}
  \label{fig:longAscii}
\end{figure}

\subsubsection{Long UTF-16 Big-Endian Strings}

If $length\_and\_kind$ has the value {\tt 90}, it is followed by a
two-byte $length$ field, and then followed by that many bytes of
UTF-16 big-endian encoded string data, as shown in Figure~\ref{fig:longUTF16BE}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{1}{\tt 90} & \bitbox{2}{$length$} &
      \bitbox[lrt]{13}{UTF-16 Big-Endian data}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Long UTF-16-BE DeviceSQL String}
  \label{fig:longUTF16BE}
\end{figure}

\subsubsection{Short ASCII Strings}
\label{sec:shortAscii}

If $length\_and\_kind$ has an odd value it is a $mangled\_length$,
labeled $m_l$ in Figure~\ref{fig:shortAscii}. This means we are
dealing with a short ASCII DeviceSQL string. To find the length of the
string data (which immediately follows this byte), subtract 1 from
$mangled\_length$, divide it by 2, and subtract 1 again.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{1}{$m_l$} & \bitbox[lrt]{15}{ASCII data}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Short ASCII DeviceSQL String}
  \label{fig:shortAscii}
\end{figure}

\section{Analysis Files}
\label{sec:analysisFiles}

When rekordbox analyzes tracks there is some data that is too big to
fit in the database itself. We have already seen some of that (the
album art images, and of course the track audio is left in the
filesystem as well). The other analysis data is organized into
``anlz'' files, whose path can be found in the DeviceSQL string
pointed to by index 14 in the string offsets found at the end of the
corresponding track row (see Table~\ref{table:trackStrings} in
Section~\ref{sec:trackRows}). These files have names like {\tt
  ANLZ0001.DAT} and their structure is described in this section.

The files are ``tagged type'' files, where there is an overall file
header section, and then each entry in the file has its own header
which identifies the type and length of that section.

Later player hardware added support for things like colored and
more-detailed waveforms. Apparently these were deemed too large to
fit in the {\tt .DAT} files, so another file was introduced, which
shares the same base filename as the {\tt .DAT} file, but uses an
extension of {\tt .EXT} instead. Both kinds of file share the same
structure, but different sets of tags can be found in each.

\subsection{Analysis File Header}

For some reason the analysis files store their numbers in big-endian
byte order, the opposite of the {\tt export.pdb} database file. Field
names used in the Figures match the IDs assigned to them in the Kaitai
Struct
specification\footnote{\url{https://github.com/Deep-Symmetry/crate-digger/blob/master/src/main/kaitai/rekordbox_anlz.ksy}},
unless that is too long to fit, in which case a subscripted
abbreviation is used, and the text will mention the actual struct
field name.

The file itself starts with the four-character code {\tt PMAI} that
identifies its format. This file format identifier is followed a
four-byte value, $len\_header$ (at bytes~{\tt 04-07}) that specifies
the length of the file header in bytes. This is followed by another
four-byte value, $len\_file$, at bytes~{\tt 08-0b} that specifies the
length of the whole file in bytes.

The header seems to usually be {\tt 1c} bytes long, though we do not
yet know the purpose of any of the header values that come after
$len\_file$. After the header, the file consists of a series of tagged
sections, each with their own four-character code identifying the
seciton type, followed by a header and the section content. This
overall structure is illustrated in
Figure~\ref{fig:anlzFileStructure}, and the structure of the known tag
types is described next.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{\tt PMAI} & \bitbox{4}{$len\_header$} & \bitbox{4}{$len\_file$} & \bitbox{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{12}{} & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \wordbox[lr]{1}{Tagged Sections} \\
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Analysis File Structure}
  \label{fig:anlzFileStructure}
\end{figure}

\subsection{Analysis File Sections}

The structure of each tagged section has an ``envelope'' that can be
understood even if the internal structure of the section is unknown,
making it easy to navigate through the file looking for the section
you need. This structure is very similar to the file itself, and is
illustrated in Figure~\ref{fig:anlzTagStructure}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{4}{$fourcc$} & \bitbox{4}{$len\_header$} & \bitbox{4}{$len\_tag$} & \bitbox[lrt]{4}{}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \wordbox[lr]{1}{Tag-Specific Content}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Tagged Section Structure}
  \label{fig:anlzTagStructure}
\end{figure}

Every section begins with a four-character code, $fourcc$, identifying
its specific structure and content, as described in the sections
below. This is followed by a four-byte value, $len\_header$, which
specifies how many bytes there are in the section header, and another
four-byte value, $len\_tag$, which specifies the length of the entire
tagged section (including the header), in bytes. This value can be
added to the address of the start of the tag to find the start of the
next tag.

There is not much value to $len\_header$. If you study the structure
of each type of tagged section, you can see some sense of where the
``header-like stuff'' ends, and ``content-like stuff'' begins, and
this seems to line up with the value of $len\_header$. But because
there are important values in each tag's header, and those always
start immediately after $len\_tag$, it is simply easier to ignore the
value of $len\_header$, and model the tag body as beginning at
byte~{\tt 0c} of the tag. To show where the boundary occurs, in the
diagrams that follow, values that fall inside the byte range of the
header are colored yellow.

\subsubsection{Beat Grid Tag}

This kind of section holds a list of all beats found within the track,
recording their bar position, the time at which they occur, and the
tempo at that point. It is identified by the four-character code {\tt
  PQTZ}, which may stand for ``Pioneer Quantization''. It has the
structure shown in Figure~\ref{fig:beatGridTagStructure}.
$len\_header$ is {\tt 18}. The tag-specific content starts with two
unknown values, although Mr. Flesniak says that $unknown_2$ seems to
always have the value {\tt 00800000}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PQTZ} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$unknown_1$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{4}{$unknown_2$} & \colorbitbox{yellow}{4}{$len\_beats$} & \bitbox[lrt]{8}{Beat Entries}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Beat Grid Tag}
  \label{fig:beatGridTagStructure}
\end{figure}

$len\_beats$ at bytes~{\tt 14-17} specifies the number of beats were
found in the track, and thus the number of beat entries that will be
present in this section. The beat entries come next, and each has the
structure shown in Figure~\ref{fig:beatEntry}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \bitbox{2}{$b_{nun}$} & \bitbox{2}{$tempo$} & \bitbox{4}{$time$} & \bitbox[]{8}{}
  \end{bytefield}
  \caption{Beat Grid Beat}
  \label{fig:beatEntry}
\end{figure}

Each beat entry is eight bytes long. It starts with $beat\_number$, a
two-byte number (abbreviated $b_{num}$ in Figure~\ref{fig:beatEntry})
which specifies where the beat falls within its measure. So the value
is always 1, 2, 3, or 4. This is followed by a two-byte $tempo$ value,
which records the track tempo at the point where this beat occurs, in
beats per minute multiplied by 100 (to allow a precision of
$\frac{1}{100}$ BPM). Finally, there is a four-byte $time$ value,
which specifies the time at which this beat would occur, in
milliseconds, when playing the track at its normal speed.

As noted above, there will be as many beat entries as $len\_beats$
specifies. They continue to the end of the tag.

\subsubsection{Cue List Tag}
\label{sec:cueTag}

This kind of section holds either a list of ordinary memory points and
loops, or a list of hot cues and hot loops. It is identified by the
four-character code {\tt PCOB}, and has the structure shown in
Figure~\ref{fig:cueTagStructure}. $len\_header$ is {\tt 18}.

Note that since the release of the Nexus 2 series of players, there is
a newer tag available that contains more information and supports more
hot cues, so you should check for that before loading this tag. See
Section~\ref{sec:extCueTag} for details.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PCOB} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$type$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{2}{$unk$} & \colorbitbox{yellow}{2}{$len_{cues}$} &
      \colorbitbox{yellow}{4}{$memory\_count$} & \bitbox[lrt]{8}{Cue Entries}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Cue List Tag}
  \label{fig:cueTagStructure}
\end{figure}

The $type$ value at bytes~{\tt 0c-0f} determines whether this section
holds memory points (if $type$ is {\tt 0}) or hot cues (if $type$ is
{\tt 1}). The number of cue entries present in the section is reported
in $len_{cues}$ at bytes~{\tt 12-13}, and we don't yet know the
meaning of $unk$ at bytes~{\tt 10-11} or $memory\_count$ at bytes~{\tt
  14-17}. The remainder of the section, from byte~{\tt 18} through
$len\_tag$ holds the cue entries themselves, with the structure shown
in Figure~\ref{fig:cueEntry}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PCPT} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_entry$} & \colorbitbox{yellow}{4}{$hot\_cue$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{4}{$status$} & \colorbitbox{yellow}{4}{$unknown_1$} &
      \colorbitbox{yellow}{2}{$o_{first}$} & \colorbitbox{yellow}{2}{$o_{last}$} &
      \bitbox{1}{$t$} & \bitbox{3}{$unknown_2$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{4}{$time$} & \bitbox{4}{$loop\_time$} & \bitbox{8}{$unknown_3$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 30}
      \bitbox{8}{} & \bitbox[]{8}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Cue List Entry}
  \label{fig:cueEntry}
\end{figure}

Each cue entry is {\tt 38} bytes long. It is structured as its own
miniature tag for unknown reasons, starting with the four-character
code {\tt PCPT} (Pioneer Cue Point?), and its own internal four-byte
$len\_header$ and $len\_entry$ values ({\tt 1c} and {\tt 38}
respectively).

If the cue is an ordinary memory point, $hot\_cue$ at bytes~{\tt
  0c-0f} will be zero, otherwise it identifies the number of the hot
cue that this entry represents (Hot Cue A is number 1, B is 2, and so
on). The $status$ value at bytes~{\tt 10-13} seems to be a deletion
indicator; if it is zero, the entry is ignored. Cues which the players
pay attention to have the value 1 here.

The next four bytes have an unknown purpose, but seem to always have
the value {\tt 00100000}. They are followed by two two-byte values,
which seem to be for sorting the cues in the proper order in some
strange way. $order\_first$ at bytes~{\tt 1a-1b} (labeled $o_{first}$
in Figure~\ref{fig:cueEntry}) has the value {\tt ffff} for the first
cue, {\tt 0000} for the second, then 2, 3 and on. $order\_last$ at
bytes~{\tt 1a-1b} (labeled $o_{last}$) has the value 1 for the first
cue, 2 for the second, and so on, but {\tt ffff} for the last. It
would seem that the cues could be perfectly well sorted by just one of
these fields, or indeed, by their $time$ values.

The first ``non-header'' field is $type$ at byte~{\tt 1c} (labeled $t$
in Figure~\ref{fig:cueEntry}), and it specifies whether the entry
records a simple position (if it has the value 1) or a loop (if it has
the value 2). The next three bytes have an unknown purpose, but seem
to always have the values {\tt 0003e8}, or decimal 1000.

The value $time$ at bytes~{\tt 20-23} records the position of the cue
within the track, as a number of milliseconds (representing when the
cue would occur if the track is being played at normal speed). If
$type$ is 2, so this cue stores a loop, then $loop\_time$ at
bytes~{\tt 24-27} stores the track time in milliseconds at which the
player should loop back to $time$.

We do not know what, if anything, is stored in the remaining bytes of
the cue entry.

\subsubsection{Extended (nxs2) Cue List Tag}
\label{sec:extCueTag}

This is a variation of the Cue List Tag described in
Section~\ref{sec:cueTag} that was introduced with the Nexus 2 players
to add support for more than three hot cues with custom color
assignments, as well as DJ-assigned comment text for each hot cue and
memory point. It also contains the information present in the standard
Cue List Tag, so you only need to read one set or the other. Beat Link
tries to use the extended tags if they are available, and falls back
to using the older ones if they are not.

Just like the older tag, this kind of section holds either a list of
ordinary memory points and loops, or a list of hot cues and hot loops.
It is identified by the four-character code {\tt PCO2}, and has the
structure shown in Figure~\ref{fig:extCueTagStructure}. $len\_header$
is {\tt 14}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PCO2} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$type$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{2}{$len_{cues}$} & \colorbitbox{yellow}{2}{{\tt 0000}} & \bitbox[lrt]{12}{Cue Entries}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Extended (nxs2) Cue List Tag}
  \label{fig:extCueTagStructure}
\end{figure}

The $type$ value at bytes~{\tt 0c-0f} determines whether this section
holds memory points (if $type$ is {\tt 0}) or hot cues (if $type$ is
{\tt 1}). The number of cue entries present in the section is reported
in $len_{cues}$ at bytes~{\tt 10-11}, and we don't yet know the
meaning of the remaining two header bytes. The remainder of the
section, from byte~{\tt 14} through $len\_tag$ holds the cue entries
themselves, with the structure shown in Figure~\ref{fig:extCueEntry}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PCP2} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_entry$} & \colorbitbox{yellow}{4}{$hot\_cue$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{1}{$t$} & \bitbox{3}{$unknown_1$} &
      \bitbox{4}{$time$} & \bitbox{4}{$loop\_time$} \bitbox{4}{$unknown_2$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \bitbox{8}{} & \bitbox{4}{$len\_comment$} & \bitbox[lrt]{4}{$comment$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \bitbox[lrb]{5}{} & \bitbox{1}{$c$} & \bitbox{1}{$r$} & \bitbox{1}{$g$} & \bitbox{1}{$b$} &
      \bitbox[lrt]{7}{$unknown_3$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \bitbox[ltb]{8}{} & \bitbox[rb]{5}{} & \bitbox[t]{3}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Extended (nxs2) Cue List Entry}
  \label{fig:extCueEntry}
\end{figure}

Each extended cue entry has a variable length. It is structured as its
own miniature tag, starting with the four-character code {\tt PCP2},
and its own internal four-byte $len\_header$ and $len\_entry$ values.
While $len\_header$ has the fixed value {\tt 10}, $len\_entry$ is
needed to determine the length of the entry, so the beginning of the
next one can be located.

If the cue is an ordinary memory point, $hot\_cue$ at bytes~{\tt
  0c-0f} will be zero, otherwise it identifies the number of the hot
cue that this entry represents (Hot Cue A is number 1, B is 2, and so
on).

The $status$ flag and mysterious sort order values present in the
older cue list entry header are simply absent here.

The first ``non-header'' field is $type$ at byte~{\tt 10} (labeled $t$
in Figure~\ref{fig:extCueEntry}), and it specifies whether the entry
records a simple position (if it has the value 1) or a loop (if it has
the value 2). The next three bytes have an unknown purpose, but seem
to always have the values {\tt 0003e8}, or decimal 1000.

The value $time$ at bytes~{\tt 14-17} records the position of the cue
within the track, as a number of milliseconds (representing when the
cue would occur if the track is being played at normal speed). If
$type$ is 2, so this cue stores a loop, then $loop\_time$ at
bytes~{\tt 18-1b} stores the track time in milliseconds at which the
player should loop back to $time$.

The next twelve bytes have an unknown purpose, but seem to have the
value {\tt 00}, except for the second byte which seems to have the
value {\tt 10}. They are followed by $len\_comment$, which contains
the length, in bytes, of the $comment$ field which immediately follows
it. If $len\_comment$ has a non-zero value, $comment$ will hold the
text of the comment, encoded as a UTF-16 Big Endian string with a
trailing {\tt NUL} character. So the length will always be even, and
(when non-zero) always at least 4 (a one character comment followed by
the trailing {\tt NUL}).

Immediately after $comment$ (in other words, starting $len\_comment +
{\tt 1c}$ past the start of the entry) there are four one-byte values
containing color information. $colorCode$ (labeled $c$ in
Figure~\ref{fig:extCueEntry}) appears to be a code identifying the
color with which rekordbox displays the cue, by looking it up in a
table. There have been sixteen codes identified, and their
corresponding RGB colors can be found by looking at the {\tt
  findRecordboxColor} static method in the Beat Link library's {\tt
  CueList}
class.\footnote{\url{https://deepsymmetry.org/beatlink/apidocs/}} The
next three bytes, $color\_red$ (labeled $r$), $color\_green$ (labeled
$g$), and $color\_blue$ (labeled $b$), make up an RGB color
specification which is similar, but not identical, to the color that
rekordbox displays. We believe these are the values used to illuminate
the RGB LEDs in a player that has loaded the cue. When no color is
associated with the cue, all four of these bytes have the value {\tt
  00}.

We do not know what, if anything, is stored in the remaining bytes of
the tag.

\subsubsection{Path Tag}

This kind of section holds the file path of the audio file for which
the track analysis was performed. It is identified by the
four-character code {\tt PPTH} and has the structure shown in
Figure~\ref{fig:pathTagStructure}. $len\_header$ is {\tt 10}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PPTH} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$len\_path$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \wordbox[lrt]{1}{$path$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Path Tag}
  \label{fig:pathTagStructure}
\end{figure}

$len\_path$ at bytes~{\tt 0c-0f} holds the length of the file path
value, which makes up the entire tag body. $path$, which starts at
byte~{\tt 10}, is a DeviceSQL string with the structure described in
Section~\ref{sec:deviceSqlStrings}.

\subsubsection{VBR Tag}

This kind of section has not yet been explained, but it is believed to
hold an index allowing rapid seeking to particular times within
variable-bit-rate tracks. (Without such a structure, it would be
necessary to scan the entire file from the beginning to find a frame
starting at a particular time, which would be too slow for jumping to
memory points or hot cues deep within the track.) What is known of the
structure is shown in Figure~\ref{fig:vbrTagStructure}. The
four-character code that identifies this type of section is {\tt PVBR}
and $len\_header$ is {\tt 10}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PVBR} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$unknown_1$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \wordbox[lrt]{1}{$unknown_2$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{VBR Tag}
  \label{fig:vbrTagStructure}
\end{figure}

\subsubsection{Waveform Preview Tag}
\label{sec:waveformPreviewTag}

This kind of section holds a fixed-width monochrome preview of the
track waveform, displayed above the touch strip on original nexus
players, providing a birds-eye view of the current playback position,
and supporting direct needle jump to specific track sections. It is
identified by the four-character code {\tt PWAV} and has the structure
shown in Figure~\ref{fig:wavePreviewTagStructure}. $len\_header$ is
{\tt 14}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PWAV} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$len\_preview$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{4}{$unknown$} & \bitbox[lrt]{12}{$data$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Waveform Preview Tag}
  \label{fig:wavePreviewTagStructure}
\end{figure}

The purpose of the header bytes~{\tt 10-13} is unknown; they always
seem to have the value {\tt 00100000}. The waveform preview data
begins at byte~{\tt 14} and is 400 (decimal) bytes long. Each byte
encodes one vertical pixel-wide column of the waveform preview. The
height of the column is represented by the five low-order bits of the
byte (so it can range from 0 to 31 pixels high), and the whiteness of
the segment is represented by the three high-order bits. Segments with
higher values in these bits sections are drawn in a less saturated
(whiter) shade of blue.

\subsubsection{Tiny Waveform Preview Tag}

This kind of section holds an even smaller fixed-width monochrome
preview of the track waveform, which seems to be displayed on the
CDJ-900. It is identified by the four-character code {\tt PWV2} but
otherwise has the same structure as the larger waveform preview tags
shown in Figure~\ref{fig:wavePreviewTagStructure}. $len\_header$ is
still {\tt 14}, and header bytes~{\tt 10-13} also seem to have the
value {\tt 00100000}. The waveform preview data begins at byte~{\tt
  14} and is 100 (decimal) bytes long. Each byte encodes one vertical
pixel-wide column of the waveform preview. The height of the column is
represented by the four low-order bits of the byte (so it can only
range from 0 to 15 pixels high), and no other bits are used.

\subsubsection{Waveform Detail Tag}

This kind of section holds a variable-width and much larger monochrome
preview of the track waveform, which scrolls along while the track
plays, giving a detailed glimpse of the neighborhood of the current
playback position. Since this is potentially much larger than other
analysis elements, and is not supported by older players, it is stored
in the extended analyis file (with extension {\tt .EXT}). It is
identified by the four-character code {\tt PWV3} and has the structure
shown in Figure~\ref{fig:waveDetailTagStructure}. $len\_header$ is
{\tt 18}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PWV3} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$len\_entry\_bytes$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{4}{$len\_entries$} & \colorbitbox{yellow}{4}{$unknown$} & \bitbox[lrt]{8}{$entries$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Waveform Detail Tag}
  \label{fig:waveDetailTagStructure}
\end{figure}

$len\_entry\_bytes$ identifies how many bytes each waveform detail
entry takes up; for this kind of tag it always has the value 1.
$len\_entries$ specifies how many entries are present in the tag. Each
entry represents one half-frame of audio data, and there are 75 frames
per second, so for each second of track audio there are 150 waveform
detail entries. The purpose of the header bytes~{\tt 14-17} is
unknown; they always seem to have the value {\tt 00960000}. The
waveform detail entries begin at byte~{\tt 18}. The interpretation of
each byte is the same as for the Waveform Preview data described in
Section~\ref{sec:waveformPreviewTag}.

\subsubsection{Waveform Color Preview Tag}

This kind of section holds a fixed-width color preview of the track
waveform, displayed above the touch strip on nexus 2 players,
providing a birds-eye view of the current playback position, and
supporting direct needle jump to specific track sections. It is also
used in rekordbox itself. This is stored in the extended analyis file
(with extension {\tt .EXT}). It is identified by the four-character
code {\tt PWV4} and has the structure shown in
Figure~\ref{fig:colorPreviewTagStructure}. $len\_header$ is {\tt 18}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PWV4} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$len\_entry\_bytes$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{4}{$len\_entries$} & \colorbitbox{yellow}{4}{$unknown$} & \bitbox[lrt]{8}{$entries$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Waveform Color Preview Tag}
  \label{fig:colorPreviewTagStructure}
\end{figure}

$len\_entry\_bytes$ identifies how many bytes each waveform preview
entry takes up; for this kind of tag it always has the value 6.
$len\_entries$ specifies how many entries are present in the tag. The
purpose of the header bytes~{\tt 14-17} is unknown. The waveform color
preview data begins at byte~{\tt 18} and is 7,200 (decimal) bytes
long, representing 1,200 columns of waveform preview information.

The color waveform preview entries are the most complex of any of the
waveform tags. See the discussion on
Github\footnote{\url{https://github.com/Deep-Symmetry/dysentery/issues/9}}
for how the analysis was performed. {\tt @jan2000} created an audio
file containing a 10 second sine wave sweep from 20 Hz to 20 kHz, and
analyzed that in rekordbox. The results are represented in
Figure~\ref{fig:sineSweepAnalysis}.

As a summary, the top six stripes plot the values of each six channels
of waveform preview information. The first byte of data is the first
column of the top stripe, the next byte is the first column of the
second stripe, and so on, until we reach the seventh byte, which is
the second column of the first stripe.

We are not sure what the top two stripes represent, but they do seem
to have an effect on the blue version of the waveform preview, so they
somehow encode ``whiteness''. The next stripe, corresponding to
byte~{\tt 2} of each column, indicates how much sound energy is
present in the bottom half of the frequency range (it drops around 10
KHz). The stripe corresponding to byte~{\tt 3} reflects how much sound
energy is present in the bottom third of the frequency range,
byte~{\tt 4} reflects how much sound energy is in the middle of the
frequency range, and byte~{\tt 5} tracks the sound energy in the top of
the frequency range.

The stripe labeled ``color'' reflect's {\tt @jan2000}'s algorithm for
combining bytes~3, 4, and 5 into a color preview, and the bottom
stripe is his approach for deriving the blue preview from that and the
other two stripes.

The calculations used by Beat Link to build its own color previews can
be found in the {\tt segmentColor} and {\tt segmentHeight} methods of
the {\tt WaveformPreview}
class\footnote{\url{https://deepsymmetry.org/beatlink/apidocs/org/deepsymmetry/beatlink/data/WaveformPreview.html}},
and the way they are used to draw the actual graphical representation
can be found in the {\tt updateWaveform} method of the {\tt
  WaveformPreviewComponent}
class\footnote{\url{https://deepsymmetry.org/beatlink/apidocs/org/deepsymmetry/beatlink/data/WaveformPreviewComponent.html}}.
These produce attractive results, but it is certainly possible that
refinements can be found in the future.

\begin{figure}
  \vspace{5mm}
  \centering
  \includegraphics[width=10cm]{assets/sine-sweep-preview}
  \caption{Sine sweep analysis}
  \label{fig:sineSweepAnalysis}
\end{figure}


\subsubsection{Waveform Color Detail Tag}

This kind of section holds a variable-width and much larger color
preview of the track waveform, introduced with the nexus 2 line, which
scrolls along while the track plays, giving a detailed glimpse of the
neighborhood of the current playback position. This is stored in the
extended analyis file (with extension {\tt .EXT}). It is identified by
the four-character code {\tt PWV5} and has the structure shown in
Figure~\ref{fig:colorDetailTagStructure}. $len\_header$ is {\tt 18}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PWV5} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$len\_entry\_bytes$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{4}{$len\_entries$} & \colorbitbox{yellow}{4}{$unknown$} & \bitbox[lrt]{8}{$entries$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Waveform Color Detail Tag}
  \label{fig:colorDetailTagStructure}
\end{figure}

$len\_entry\_bytes$ identifies how many bytes each waveform detail
entry takes up; for this kind of tag it always has the value 2.
$len\_entries$ specifies how many entries are present in the tag. Each
entry represents one half-frame of audio data, and there are 75 frames
per second, so for each second of track audio there are 150 waveform
detail entries. The purpose of the header bytes~{\tt 14-17} is
unknown; they may always have the value {\tt 00960305}. The color
waveform detail entries begin at byte~{\tt 18}.

Color detail entries are much simpler than color preview entries. They
consist of three-bit red, green, and blue components and a five-bit
height component packed into the sixteen bits of the two entry bytes.
Considering each entry as a two-byte big-endian integer, the red
component is the three high-order bits. The next three bits are the
green component, followed by the three bits of blue intensity, and
finally five bits of height. The two low-order bits do not seem to be
used. This is shown in Figure~\ref{fig:colorDetailSegment}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \bitbox[]{1}{\tiny\bfseries f}
    \bitbox[]{1}{\tiny\bfseries e}
    \bitbox[]{1}{\tiny\bfseries d}
    \bitbox[]{1}{\tiny\bfseries c}
    \bitbox[]{1}{\tiny\bfseries b}
    \bitbox[]{1}{\tiny\bfseries a}
    \bitbox[]{1}{\tiny\bfseries 9}
    \bitbox[]{1}{\tiny\bfseries 8}
    \bitbox[]{1}{\tiny\bfseries 7}
    \bitbox[]{1}{\tiny\bfseries 6}
    \bitbox[]{1}{\tiny\bfseries 5}
    \bitbox[]{1}{\tiny\bfseries 4}
    \bitbox[]{1}{\tiny\bfseries 3}
    \bitbox[]{1}{\tiny\bfseries 2}
    \bitbox[]{1}{\tiny\bfseries 1}
    \bitbox[]{1}{\tiny\bfseries 0} \\

    \bitbox{3}{$red$} & \bitbox{3}{$green$}& \bitbox{3}{$blue$}& \bitbox{5}{$height$} &
    \bitbox{1}{\tt 0} & \bitbox{1}{\tt 0}
  \end{bytefield}
  \caption{Waveform color detail segment bits}
  \label{fig:colorDetailSegment}
\end{figure}

\subsubsection{Song Structure Tag}

This kind of section is used only in rekordbox Performance Mode, and
so does not get exported to external media. If you want to work with
song structure data, you will need to find the extended analysis file
on the computer hosting rekordbox. Within that file, the section is
identified by the four-character code {\tt PSSI} and has the structure
shown in Figure~\ref{fig:songStructureTagStructure}. $len\_header$ is
{\tt 20}. Many thanks to Michael Ganss,
\url{https://github.com/mganss}, for contributing this analysis.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \colorbitbox{yellow}{4}{\tt PSSI} & \colorbitbox{yellow}{4}{$len\_header$} &
      \colorbitbox{yellow}{4}{$len\_tag$} & \colorbitbox{yellow}{4}{$len\_entry\_bytes$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \colorbitbox{yellow}{2}{$len_e$} & \colorbitbox{yellow}{2}{$style$} & \colorbitbox{yellow}{6}{$unknown$} &
      \colorbitbox{yellow}{2}{$end$} & \colorbitbox{yellow}{4}{$unknown_2$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 20}
      \wordbox[lrt]{1}{$entries$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{}
      \skippedwords \\
      \wordbox[lrb]{1}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Song Structure Tag}
  \label{fig:songStructureTagStructure}
\end{figure}

$len\_entry\_bytes$ identifies how many bytes each phrase entry takes
up; so far it always has the value {\tt 18}, so each entry takes
twenty four bytes. $len\_entries$ at bytes~{\tt 10-11} (labeled
$len_e$ in Figure~\ref{fig:songStructureTagStructure}) specifies how
many entries are present in the tag. Each entry represents one
recognized phrase. $phrase\_style$ at bytes~{\tt 12-13} (labeled
$phrase$) specifies the overall type of phrase structure that
rekordbox chose to represent the song. The value $1$ is an ``up-down''
style where the main phrases consist of ``UP'', ``DOWN'', and
``CHORUS'', and is represented in rekordbox by white label text. The
value $2$ is a ``bridge-verse'' style where the main phrases are
labeled ``VERSE'', ``CHORUS'', and ``BRIDGE'', and the label text in
rekordbox is black. Style $3$ is mostly identical to bridge-verse,
except verses 1--3 are labeled ``VERSE1'' and verses 4--6 are labeled
``VERSE2'' in rekordbox.

The purpose of the header bytes~{\tt 14-19} is unknown. $end\_beat$ at
bytes~{\tt 1a-1b} (labeled $end$ in
Figure~\ref{fig:songStructureTagStructure}) holds the beat number at
which the last recognized phrase ends. The track may continue beyond
this, but will mostly be silence from then on.

The final four bytes of the header, {\tt 1c-1f}, also have an unknown
purpose.

The phrase entries begin at byte~{\tt 20}, and
each has the structure shown in Figure~\ref{fig:songStructureEntry}.

\begin{figure}
  \begin{bytefield}[bitwidth=1.9em, leftcurly=., leftcurlyspace=0pt, boxformatting={\baselinealign}]{16}
    \hexhead \\
    \begin{leftwordgroup}{\tiny\bfseries 00}
      \bitbox{2}{$phr_{num}$} & \bitbox{2}{$beat$} & \bitbox{2}{$phr_{id}$} & \bitbox{10}{$unknown$}
    \end{leftwordgroup} \\
    \begin{leftwordgroup}{\tiny\bfseries 10}
      \bitbox{5}{} & \bitbox{1}{$f$} & \bitbox{2}{$f_b$} & \bitbox[]{8}{}
    \end{leftwordgroup}
  \end{bytefield}
  \caption{Song Structure Entry}
  \label{fig:songStructureEntry}
\end{figure}

The first two bytes of each song structure entry hold $phrase\_number$
(labeled $phr_{num}$ in Figure~\ref{fig:songStructureEntry}) which
numbers each phrase, starting at one and incrementing with each entry.
That is followed by $beat\_number$ (labeled $beat$), a two-byte value
that specifies the beat at which this phrase begins in the track. It
continues until either the beat number of the next phrase, or the beat
identified by $end$ in the tag header if this is the last entry.

$phrase\_id$ at bytes~{\tt 4-5} (labeled $phr_{id}$ in
Figure~\ref{fig:songStructureEntry}) specifies what kind of phrase
rekordbox has identified here. The interpretation depends on the value
of $phrase\_style$ in the tag header, as is detailed in
Table~\ref{table:phraseLabels} below.

The purpose of the entry bytes~{\tt 6-14} is unknown. $fill\_in$ at
byte~{\tt 15} (labeled $f$ in Figure~\ref{fig:songStructureEntry}) is
a flag that indicates whether there are fill (non-phrase) beats at the
end of the phrase. If it is non-zero, then $fill\_in\_beat\_number$ at
bytes~{\tt 16-17} (labeled $f_b$) holds the beat number at which the
fill begins. When fill-in is present, it is indicated in rekordbox by
little dots on the full waveform. The manual says:

\begin{quote}
  [Fill in] is a section that provides improvisational changes at the
  end of phrase. [Fill in] is detected at the end of Intro, Up, and
  Chorus (up to 4 beats).
\end{quote}

\begin{longtabu}{rrl}
  \toprule
  {\bfseries Phrase Style} & {\bfseries Phrase ID} & {\bfseries Label} \endhead

  \bottomrule \\
  \caption{Phrase Labels} \endfoot

  1 & 1 & INTRO \label{table:phraseLabels} \\
  1 & 2 & UP \\
  1 & 3 & DOWN \\
  1 & 5 & CHORUS \\
  1 & 6 & OUTRO \\
  \midrule
  2 & 1 & INTRO \\
  2 & 2 & VERSE1 \\
  2 & 3 & VERSE2 \\
  2 & 4 & VERSE3 \\
  2 & 5 & VERSE4 \\
  2 & 6 & VERSE5 \\
  2 & 7 & VERSE6 \\
  2 & 8 & BRIDGE \\
  2 & 9 & CHORUS \\
  2 & 10 & OUTRO \\
  \midrule
  3 & 1 & INTRO \\
  3 & 2 & VERSE1 \\
  3 & 3 & VERSE1 \\
  3 & 4 & VERSE1 \\
  3 & 5 & VERSE2 \\
  3 & 6 & VERSE2 \\
  3 & 7 & VERSE2 \\
  3 & 8 & BRIDGE \\
  3 & 9 & CHORUS \\
  3 & 10 & OUTRO \\

\end{longtabu}

Note that because Kaitai Struct does not allow multiple enum values to
share the same label, style 3 is modeled in Crate Digger as identical
to style 2.

\section{Crate Digger}

You can find a Java library that can parse the structures described in
this research, and that can retrieve them from players' NFS servers,
at: \url{https://github.com/deep-symmetry/crate-digger}

The project also contains Kaitai Struct specifications for the file
structures, which were used to automatically generate Java classes to
parse them, and which can be used to generate equivalent code for a
variety of other programming languages.

There are also ONC RPC specification files which were similarly used
to generate Java classes to communicate with the NFSv2 servers in the
players, and which can likely be used to generate structures for other
languages as well.

\begin{appendix}

  \addcontentsline{toc}{section}{\listfigurename}
  \listoffigures

  \addcontentsline{toc}{section}{\listtablename}
  \listoftables

  \begin{center}
    \begin{samepage}
      \includegraphics[width=4cm]{assets/DS-Logo-bw-4k}

      \vspace{0.25cm}
      \url{http://deepsymmetry.org}
    \end{samepage}
  \end{center}

\end{appendix}

\end{document}
